# Содержимое файла: scheduler_runner\tasks\cameras\CleanupScript.py
"""
CleanupScript.py

Скрипт автоматической очистки указанных директорий от устаревших файлов и пустых папок для задачи cameras.

Назначение:
    - Удаление файлов старше заданного количества дней.
    - Удаление пустых папок после очистки.
    - Гибкая настройка сценариев (local/network) через конфиги задачи cameras.
    - Централизованное логирование и обработка ошибок.

Архитектура:
    - Аргументы командной строки позволяют выбрать сценарий, порог возраста файлов и уровень логирования.
    - Все параметры по умолчанию берутся из cleanup_config.py.
    - Операции с файловой системой реализованы через scheduler_runner.utils.filesystem.
    - Логирование через scheduler_runner.utils.logging.

Пример запуска:
    python -m scheduler_runner.tasks.cameras.CleanupScript --input_dir_scenario local --max_age_days 7 --detailed_logs

Author: anikinjura
"""
__version__ = '0.0.2'

import argparse
import logging
import sys
from pathlib import Path

from scheduler_runner.tasks.cameras.config.scripts.cleanup_config import SCRIPT_CONFIG, SCHEDULE
from scheduler_runner.utils.filesystem import (
    remove_old_files,
    remove_empty_folders,
    ensure_directory_exists,
    FileSystemUtils,
)
from scheduler_runner.utils.logging import configure_logger

def parse_arguments() -> argparse.Namespace:
    """
    Парсит и возвращает аргументы командной строки.

    Аргументы:
      --input_dir_scenario: сценарий, по которому выбирается работа скрипта: локально ("local") или в облаке ("network").
      --max_age_days: Порог возраста файлов в днях, файлы старше которого будут удалены.
      --detailed_logs / --no-detailed_logs: Включить или отключить детализированное логирование.
      
    Returns:
        argparse.Namespace: Объект с распарсенными аргументами.
    """
    parser = argparse.ArgumentParser(
        description="Скрипт для удаления старых файлов и пустых папок",
        epilog="Пример: python CleanupScript.py --input_dir_scenario local --max_age_days 15 --detailed_logs"
    )
    parser.add_argument(
        "--input_dir_scenario",
        type=str,
        required=True,
        choices=["local", "network"],
        help=f"Сценарий, по которому выбирается работа скрипта: local или network"
    )
    parser.add_argument(
        "--max_age_days",
        type=int,
        help=f"Порог возраста файлов в днях (по умолчанию: из конфигурации для выбранного сценария)"
    )
    parser.add_argument(
        "--detailed_logs",
        dest="detailed_logs",
        action="store_true",
        help="Включить детализированные логи"
    )
    parser.add_argument(
        "--no-detailed_logs",
        dest="detailed_logs",
        action="store_false",
        help="Отключить детализированные логи"
    )
    # Значение по умолчанию для аргумента detailed_logs в None, если пользователь не указал ни --detailed_logs, ни --no-detailed_logs в командной строке
    parser.set_defaults(detailed_logs=None)

    return parser.parse_args()

def execute_cleanup_operations(logger: logging.Logger, input_dir: Path, max_age_days: int) -> None:
    """
    Выполняет операции очистки (удаление файлов и пустых папок) и логирует результаты.

    Эта функция вызывает методы удаления файлов и директорий из модуля utils.py,
    а результаты каждой операции записываются в основной лог-файл.

    Args:
        logger: Настроенный логгер для записи информации.
        input_dir (Path): Входная директория для очистки, выбранная в зависимости от сценария.
        max_age_days (int): Порог возраста файлов в днях; удаляются только файлы старше этого порога.

    Raises:
        RuntimeError: При возникновении критической ошибки выполнения операций.

    Используемые функции:
        - remove_old_files(...) -> dict: {'DeletedFiles': int, 'FileDeletionErrors': int}
        - remove_empty_folders(...) -> dict: {'DeletedFolders': int, 'FolderDeletionErrors': int}
        - write_operation_log(...): записывает сообщения в лог-файл
    """
    try:
        # Удаление файлов, которые старше указанного порога (в днях)
        file_result = remove_old_files(
            target_folder = input_dir,
            days_threshold = max_age_days,
            logger=logger
        )
    except Exception as e:
        logger.error(f"Ошибка при удалении старых файлов: {e}", exc_info=True)
        raise

    try:
        # Удаление пустых директорий
        folder_result = remove_empty_folders(
            target_folder = input_dir,
            logger=logger,
        )
    except Exception as e:
        logger.error(f"Ошибка при удалении пустых папок: {e}", exc_info=True)
        raise

    # Формирование сводной информации по количеству удаленных файло и директорий
    logger.info(
        "Сводка: Удалено файлов - %d, ошибок удаления файлов - %d, "
        "удалено папок - %d, ошибок удаления папок - %d",
        file_result.get("removed", 0),
        file_result.get("errors", 0),
        folder_result.get("removed", 0),
        folder_result.get("errors", 0)
    )

def get_scenario_config(scenario: str) -> dict:
    """
    Возвращает параметры конфигурации для выбранного сценария.

    Args:
        scenario (str): Имя сценария ('local' или 'network').

    Returns:
        dict: Конфиг для выбранного сценария.

    Raises:
        ValueError: Если сценарий не найден в SCRIPT_CONFIG.
    """    
    scenario = scenario.lower()
    if scenario not in SCRIPT_CONFIG:
        raise ValueError(f"Неизвестный сценарий: {scenario}. Допустимые значения: {', '.join(SCRIPT_CONFIG.keys())}")
    return SCRIPT_CONFIG[scenario]

def main() -> None:
    """
    Основная функция выполнения скрипта очистки.

    Этапы:
      1. Разбор аргументов командной строки, выбор конфигурации для указанного сценария и определение параметров очистки. 
      2. Настройка логера.
      3. Валидация директории для очистки.
      4. Выполнение операций очистки и логирование результатов.
      5. Обработка исключений с критическим завершением при ошибке и корректное завершение.

    Возвращаемое значение:
        None

    Пример использования:
        python CleanupScript.py --input_dir_scenario local --max_age_days 15 --detailed_logs
    """
    # Разбор аргументов командной строки, выбор конфигурации для указанного сценария и определение параметров очистки.
    args = parse_arguments()                                                                                # парсинг параметров, указаных в командной строке
    scenario_config = get_scenario_config(args.input_dir_scenario)

    # Устанавливаем параметры. Приоритет: аргументы командной строки > конфиг сценария.
    max_age_days = args.max_age_days if args.max_age_days is not None else scenario_config["MAX_AGE_DAYS"]           # значение по умолчанию берем из конфига в соответствии с выбранным сценарием
    if args.detailed_logs is not None:                      # detailed_logs может быть True, False или None
        detailed_logs = args.detailed_logs
    else:
        detailed_logs = scenario_config["DETAILED_LOGS"]    # если detailed_logs не указан в командной строке, то берем из конфига                                                 # значение по умолчанию берем из конфига в соответствии с выбранным сценарием
    input_dir = scenario_config["CLEANUP_DIR"]

    # Формируем параметры для логгера
    user = scenario_config.get("USER", "operator")
    task_name = scenario_config.get("TASK_NAME", f"CleanupScript_{args.input_dir_scenario}")

    logger = configure_logger(
        user=user,
        task_name=task_name,
        detailed=detailed_logs
    )

    # Валидация и подготовка директории для очистки
    try:
        if not FileSystemUtils.validate_writable_path(input_dir):
            logger.critical(f"Нет доступа на запись в директорию: {input_dir}")
            sys.exit(1)
        ensure_directory_exists(input_dir, logger=logger)
    except Exception as e:
        logger.critical(f"Ошибка подготовки директории: {e}", exc_info=True)
        sys.exit(1)

    logger.info("Старт очистки: %s (Порог: %d дней)", input_dir, max_age_days)

    # Выполнение операций очистки и логирование результатов.
    try:
        execute_cleanup_operations(logger, input_dir, max_age_days)
    # Обработка исключений с критическим завершением при ошибке.
    except Exception as e:
        logger.critical(f"Процедура очистки завершена с ошибкой: {str(e)}", exc_info=True)
        sys.exit(1)
    finally:
        logger.info("Процедура очистки завершена.")

if __name__ == "__main__":
    main()

# Содержимое файла: scheduler_runner\tasks\cameras\CloudMonitorScript.py
"""
CloudMonitorScript.py

Скрипт для мониторинга доступности облачного хранилища.

- Проверяет возможность записи во внешнюю директорию (cloud).
- Повторяет попытки проверки, если неудачно.
- При ошибке отправляет уведомление через Telegram.

Author: anikinjura
"""
__version__ = '1.2.0'

import argparse
import logging
import sys
from pathlib import Path
import tempfile
import time

from scheduler_runner.tasks.cameras.config.scripts.cloudmonitor_config import SCRIPT_CONFIG
from scheduler_runner.utils.logging import configure_logger
from scheduler_runner.utils.notify import send_telegram_message

def parse_arguments() -> argparse.Namespace:
    """
    Парсит аргументы командной строки для скрипта мониторинга облачного хранилища.
    """
    parser = argparse.ArgumentParser(
        description="Мониторинг доступности облачного хранилища",
        epilog="Пример: python CloudMonitorScript.py --detailed_logs"
    )
    parser.add_argument(
        "--detailed_logs",
        action="store_true",
        default=False,
        help="Включить детализированные логи"
    )
    parser.add_argument(
        "--retries",
        type=int,
        default=SCRIPT_CONFIG["RETRIES"],
        help="Количество попыток проверки облачного хранилища"
    )
    parser.add_argument(
        "--delay",
        type=int,
        default=SCRIPT_CONFIG["DELAY"],
        help="Задержка между попытками в секундах"
    )
    return parser.parse_args()

def test_cloud_accessibility(dest_dir: Path, logger: logging.Logger) -> tuple[bool, str]:
    """
    Тестирует доступность облачного хранилища путем создания временного файла.
    """
    try:
        if not dest_dir.exists():
            logger.warning(f"Целевая директория {dest_dir} не существует")
            return False, f"Директория {dest_dir} не существует"
        if not dest_dir.is_dir():
            logger.error(f"Путь {dest_dir} не является директорией")
            return False, f"{dest_dir} не является директорией"
        with tempfile.NamedTemporaryFile(dir=dest_dir, prefix="cloud_test_", suffix=".tmp", delete=True) as tmp:
            tmp.write(b"test")
            tmp.flush()
        logger.info("Проверка доступности облачного хранилища: Успешно")
        return True, "Успешно"
    except Exception as e:
        logger.error(f"Ошибка проверки доступности: {e}", exc_info=True)
        return False, str(e)

def send_notification(message: str, logger: logging.Logger) -> bool:
    """
    Отправляет уведомление через Telegram.
    """
    token = SCRIPT_CONFIG["TOKEN"]
    chat_id = SCRIPT_CONFIG["CHAT_ID"]
    if not token or not chat_id:
        logger.warning("Параметры Telegram не заданы, уведомление не отправлено")
        return False
    success, result = send_telegram_message(token, chat_id, message, logger)
    if success:
        logger.info("Уведомление успешно отправлено через Telegram")
    else:
        logger.error("Ошибка отправки уведомления через Telegram: %s", result)
    return success

def main() -> None:
    """
    Основная функция скрипта мониторинга облачного хранилища.
    """
    args = parse_arguments()
    logger = configure_logger(
        user=SCRIPT_CONFIG["USER"],
        task_name=SCRIPT_CONFIG["TASK_NAME"],
        detailed=args.detailed_logs if args.detailed_logs is not None else SCRIPT_CONFIG["DETAILED_LOGS"]
    )

    dest_dir = Path(SCRIPT_CONFIG["CHECK_DIR"])
    retries = args.retries
    delay = args.delay
    success = False
    last_error = "Неизвестная ошибка"

    logger.info("Начало мониторинга облачного хранилища %s", dest_dir)

    for attempt in range(1, retries + 1):
        logger.debug("Попытка %d из %d", attempt, retries)
        accessibility_result, error_message = test_cloud_accessibility(dest_dir, logger)
        if accessibility_result:
            logger.info("Облачное хранилище доступно после %d попытки(попыток)", attempt)
            success = True
            break
        else:
            last_error = error_message
            logger.debug("Попытка %d неудачна: %s", attempt, error_message)
            if attempt < retries:
                logger.debug("Ожидание %d секунд до следующей попытки...", delay)
                time.sleep(delay)

    if not success:
        failure_message = (
            f"КРИТИЧЕСКАЯ ОШИБКА: Облачное хранилище недоступно после {retries} попыток проверки. "
            f"ПВЗ: {SCRIPT_CONFIG['PVZ_ID']}, Путь: {dest_dir}. "
            f"Последняя ошибка: {last_error}. "
            f"Требуется срочное вмешательство!"
        )
        notification_message = (
            f"ПВЗ: {SCRIPT_CONFIG['PVZ_ID']}, облачное хранилище недоступно. Требуется срочное вмешательство!"
        )
        logger.critical(failure_message)
        send_notification(notification_message, logger)

    logger.info("Мониторинг облачного хранилища завершен. Статус: %s", "УСПЕШНО" if success else "ОШИБКА")
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# Содержимое файла: scheduler_runner\tasks\cameras\config\cameras_list.py
"""
cameras_list.py

Справочник камер по каждому объекту (PVZ_ID).

Используется для получения перечня камер и их свойств (id, uid, локация) для конкретного объекта.
Необходим для скриптов мониторинга и проверки наличия записей с камер.

Пример использования:
    from config.base_config import PVZ_ID
    from .cameras_list import CAMERAS_BY_PVZ

    cameras = CAMERAS_BY_PVZ.get(PVZ_ID, {})
    for zone, cameras_in_zone in cameras.items():
        for cam in cameras_in_zone:
            print(cam['id'], cam['uid'], cam['локация'])

Структура CAMERAS_BY_PVZ:
    {
        <PVZ_ID>: {
            "<зона>": [
                {"id": str, "uid": str, "локация": str},
                ...
            ],
            ...
        },
        ...
    }
Author: anikinjura
"""
__version__ = '0.0.1'

CAMERAS_BY_PVZ = {
    10: {
        "склад": [
            {"id": "unv_001",    "uid": "sklad",        "локация": "над стелажами"},
            {"id": "xiaomi_001", "uid": "78df72028ea2", "локация": "в углу"}
        ],
        "клиентская зона": [
            {"id": "unv_002",    "uid": "client_area",  "локация": "над ресепшн"},
            {"id": "xiaomi_002", "uid": "78df72026947", "локация": "в углу у ресепшн"}
        ]
    },
    143: {
        "склад": [
            {"id": "unv_001",    "uid": "sklad",        "локация": "над стелажами"},
            {"id": "xiaomi_001", "uid": "78df7202b352", "локация": "около микроволновки"}
        ],
        "клиентская зона": [
            {"id": "unv_002",    "uid": "client_area",  "локация": "над ресепшн"},
            {"id": "xiaomi_002", "uid": "788b2a541a46", "локация": "сзади ресепшн"}
        ]
    },
    144: {
        "склад": [
            {"id": "unv_001",    "uid": "sklad",        "локация": "над стелажами"},
            {"id": "xiaomi_001", "uid": "78df72028f13", "локация": "у входа в зону склада"}
        ],
        "клиентская зона": [
            {"id": "unv_002",    "uid": "client_area",  "локация": "над ресепшн"},
            {"id": "xiaomi_002", "uid": "788b2aab4458", "локация": "сзади ресепшн"},
            {"id": "xiaomi_003", "uid": "78df7202a163", "локация": "перед ресепшн"}
        ]
    },
    182: {
        "склад": [
            {"id": "unv_001", "uid": "sklad", "локация": "у входа в зону склада"}
        ],
        "клиентская зона": [
            {"id": "unv_002", "uid": "client_area", "локация": "над ресепшн"},
            {"id": "xiaomi_001", "uid": "78df72038335", "локация": "у ресепшн"}
        ]
    },
    340: {
        "склад": [
            {"id": "unv_001", "uid": "sklad", "локация": "в районе перегородки"},
        ],
        "клиентская зона": [
            {"id": "unv_002", "uid": "client_area", "локация": "над столом проверки"},
            {"id": "xiaomi_001", "uid": "78df72038cf0", "локация": "напротив примерочных"}
        ]
    }
}

# Содержимое файла: scheduler_runner\tasks\cameras\config\cameras_paths.py
"""
cameras_paths.py

Определяет все специфичные для задачи cameras пути и переменные, зависящие от среды (production/test) и PVZ_ID.

Используется для централизованного хранения путей к локальным, сетевым и резервным директориям с видеозаписями.

Пример использования:
    from .cameras_paths import CAMERAS_PATHS
    local_path = CAMERAS_PATHS['CAMERAS_LOCAL']

Структура CAMERAS_PATHS:
    {
        'CAMERAS_LOCAL': Path,   # Путь к локальной директории с видеоархивом
        'CAMERAS_NETWORK': Path, # Путь к сетевой директории с видеоархивом
    }

Author: anikinjura
"""
__version__ = '0.0.1'

from pathlib import Path
import os
from config.base_config import PVZ_ID, ENV_MODE

if ENV_MODE == 'production':
    CAMERAS_LOCAL = Path('D:/camera')
    CAMERAS_NETWORK = Path('O:/cameras') / str(PVZ_ID)
    TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN_PROD")               # Токен для продакшен-бота
    TELEGRAM_CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID_PROD")           # Чат-ID для продакшен-чата    
else:
    CAMERAS_LOCAL = Path('C:/TestEnvironment/D_camera')
    CAMERAS_NETWORK = Path('C:/TestEnvironment/O_cameras') / str(PVZ_ID)
    TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN_TEST")               # Токен для продакшен-бота
    TELEGRAM_CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID_TEST")           # Чат-ID для продакшен-чата    

CAMERAS_PATHS = {
    'CAMERAS_LOCAL': CAMERAS_LOCAL,
    'CAMERAS_NETWORK': CAMERAS_NETWORK,
    'TELEGRAM_TOKEN': TELEGRAM_TOKEN,
    'TELEGRAM_CHAT_ID': TELEGRAM_CHAT_ID,
}

# Содержимое файла: scheduler_runner\tasks\cameras\config\cameras_schedule.py
"""
cameras_schedule.py
Автоматически собирает расписания всех скриптов задачи cameras из config/scripts/*_config.py.
Принимает: SCHEDULE (список с расписанием отдельного скрипта задачи) из каждого скриптового конфига.
Экспортирует: TASK_SCHEDULE (список с расписанием всей задачи cameras) для ядра планировщика.
Author: anikinjura
"""
__version__ = '0.0.4'

from scheduler_runner.utils.schedule_utils import collect_task_schedule

TASK_SCHEDULE = collect_task_schedule("cameras")

# Содержимое файла: scheduler_runner\tasks\cameras\config\scripts\cleanup_config.py
"""
cleanup_config.py

Параметры и расписание для CleanupScript задачи cameras.

Сценарии работы скрипта:
    - local: параметры для локального сценария
    - network: параметры для сетевого сценария

Author: anikinjura
"""
__version__ = '0.0.1'

from scheduler_runner.tasks.cameras.config.cameras_paths import CAMERAS_PATHS

MODULE_PATH = "scheduler_runner.tasks.cameras.CleanupScript"

# Конфигурация для скрипта
SCRIPT_CONFIG = {
    "local": {
        "CLEANUP_DIR": CAMERAS_PATHS["CAMERAS_LOCAL"],  # Путь к записям для очистки
        "MAX_AGE_DAYS": 8,                              # Максимальный возраст файлов для удаления  
        "DETAILED_LOGS": False,                         # Флаг по умолчанию (если не задан в аргументах --detailed_logs) для включения детализированного логирования
        "USER": "camera",                               # Пользователь, от имени которого выполняется задача   
        "TASK_NAME": "CleanupScript_local",             # Имя задачи для логирования
    },
    "network": {
        "CLEANUP_DIR": CAMERAS_PATHS["CAMERAS_NETWORK"],
        "MAX_AGE_DAYS": 120,
        "DETAILED_LOGS": True,
        "USER": "operator",
        "TASK_NAME": "CleanupScript_network",        
    },
}

# Расписание задач запуска скрипта для ядра планировщика.
# Каждая задача содержит имя, модуль, аргументы, расписание, время и пользователя
SCHEDULE = [
    {
        "name": SCRIPT_CONFIG["local"]["TASK_NAME"],
        "module": MODULE_PATH,
        "args": ["--input_dir_scenario", "local"],
        "schedule": "daily",
        "time": "20:45",
        "user": SCRIPT_CONFIG["local"]["USER"]
    },
    {
        "name": SCRIPT_CONFIG["network"]["TASK_NAME"],
        "module": MODULE_PATH,
        "args": ["--input_dir_scenario", "network"],
        "schedule": "daily",
        "time": "20:55",
        "user": SCRIPT_CONFIG["network"]["USER"]
    },
]

# Содержимое файла: scheduler_runner\tasks\cameras\config\scripts\cloudmonitor_config.py
"""
cloudmonitor_config.py

Конфиг для CloudMonitorScript задачи cameras.

Author: anikinjura
"""
__version__ = '0.0.1'

from scheduler_runner.tasks.cameras.config.cameras_paths import CAMERAS_PATHS
from config.base_config import PVZ_ID

MODULE_PATH = "scheduler_runner.tasks.cameras.CloudMonitorScript"

SCRIPT_CONFIG = {
    "PVZ_ID": PVZ_ID,
    "CHECK_DIR": CAMERAS_PATHS["CAMERAS_NETWORK"],      # Путь к облачному хранилищу для проверки
    "TOKEN": CAMERAS_PATHS["TELEGRAM_TOKEN"],           # Telegram bot_token
    "CHAT_ID": CAMERAS_PATHS["TELEGRAM_CHAT_ID"],       # Telegram chat_id
    "RETRIES": 4,                                       # Количество попыток проверки
    "DELAY": 10,                                        # Задержка между попытками (сек)
    "DETAILED_LOGS": False,                             # Флаг по умолчанию (если не задан в аргументах --detailed_logs) для включения детализированного логирования
    "USER": "operator",                                 # Пользователь для логирования
    "TASK_NAME": "CloudMonitorScript",                  # Имя задачи для логирования
}

SCHEDULE = [
    {
        "name": SCRIPT_CONFIG["TASK_NAME"],
        "module": MODULE_PATH,
        "args": [],
        "schedule": "hourly",
        "user": SCRIPT_CONFIG["USER"]
    }
]

# Содержимое файла: scheduler_runner\tasks\cameras\config\scripts\copy_config.py
"""
copy_config.py

Параметры и расписание для CopyScript задачи cameras.

Author: anikinjura
"""
__version__ = '0.0.1'

from scheduler_runner.tasks.cameras.config.cameras_paths import CAMERAS_PATHS

MODULE_PATH = "scheduler_runner.tasks.cameras.CopyScript"

SCRIPT_CONFIG = {
    "INPUT_DIR": CAMERAS_PATHS["CAMERAS_LOCAL"],
    "OUTPUT_DIR": CAMERAS_PATHS["CAMERAS_NETWORK"],
    "MAX_AGE_DAYS": 3,
    "ON_CONFLICT": "skip",          # skip/rename
    "DETAILED_LOGS": False,         # Флаг по умолчанию (если не задан в аргументах --detailed_logs) для включения детализированного логирования
    "USER": "operator",
    "TASK_NAME": "CopyScript",
}

SCHEDULE = {
    "name": SCRIPT_CONFIG["TASK_NAME"],
    "module": MODULE_PATH,
    "args": ["--shutdown 30"],
    "schedule": "daily",
    "time": "21:10",
    "user": SCRIPT_CONFIG["USER"],
}

# Содержимое файла: scheduler_runner\tasks\cameras\config\scripts\videomonitor_config.py
"""
videomonitor_config.py

Конфиг для VideoMonitorScript задачи cameras.

Author: anikinjura
"""
__version__ = '0.0.1'

from scheduler_runner.tasks.cameras.config.cameras_paths import CAMERAS_PATHS
from scheduler_runner.tasks.cameras.config.cameras_list import CAMERAS_BY_PVZ
from config.base_config import PVZ_ID

MODULE_PATH = "scheduler_runner.tasks.cameras.VideoMonitorScript"

# Конфигурация для скрипта
SCRIPT_CONFIG = {
    "PVZ_ID": PVZ_ID,                                   # Идентификатор объекта
    "CAMERAS": CAMERAS_BY_PVZ.get(PVZ_ID, {}),          # Список камер для проверки
    "TOKEN": CAMERAS_PATHS["TELEGRAM_TOKEN"],           # Telegram bot_token
    "CHAT_ID": CAMERAS_PATHS["TELEGRAM_CHAT_ID"],       # Telegram chat_id   
    
    # Параметры для локальной и сетевой проверки:
    "local": {
        "CHECK_DIR": CAMERAS_PATHS["CAMERAS_LOCAL"],    # Путь к записям для проверки полноты записей
        "MAX_LOOKBACK_HOURS": 2,                        # Определяет, на сколько часов назад скрипт должен проверять наличие записей  
        "DETAILED_LOGS": False,                         # Флаг по умолчанию (если не задан в аргументах --detailed_logs) для включения детализированного логирования
        "USER": "operator",                             # Пользователь, от имени которого выполняется задача   
        "TASK_NAME": "VideoMonitorScript_local",        # Имя задачи для логирования
    },
    "network": {
        "CHECK_DIR": CAMERAS_PATHS["CAMERAS_NETWORK"],      
        "MAX_LOOKBACK_HOURS": 24,                               
        "DETAILED_LOGS": False,                          
        "USER": "operator",                                
        "TASK_NAME": "VideoMonitorScript_network",        
    },
}

# Расписание задач запуска скрипта для ядра планировщика.
SCHEDULE = [
    {
        "name": SCRIPT_CONFIG["local"]["TASK_NAME"],
        "module": MODULE_PATH,
        "args": ["--check_type", "local"],
        "schedule": "hourly",
        "user": SCRIPT_CONFIG["local"]["USER"]
    },
    {
        "name": SCRIPT_CONFIG["network"]["TASK_NAME"],
        "module": MODULE_PATH,
        "args": ["--check_type", "network"],
        "schedule": "daily",
        "time": "12:00",
        "user": SCRIPT_CONFIG["network"]["USER"]
    },
]

# Содержимое файла: scheduler_runner\tasks\cameras\CopyScript.py
"""
CopyScript.py

Скрипт автоматического копирования файлов по возрастному критерию для задачи cameras.

- Копирует файлы из INPUT_DIR в OUTPUT_DIR, если им не больше MAX_AGE_DAYS.
- Обрабатывает конфликты имён файлов (skip/rename).
- Централизованное логирование.
- Поддержка детализированных логов и выключения ПК по завершении.

Author: anikinjura
"""
__version__ = '1.2.0'

import argparse
import sys
import time
from pathlib import Path

from scheduler_runner.tasks.cameras.config.scripts.copy_config import SCRIPT_CONFIG, SCHEDULE
from scheduler_runner.utils.filesystem import (
    copy_recent_files,
    ensure_directory_exists,
    FileSystemUtils,
)
from scheduler_runner.utils.logging import configure_logger
from scheduler_runner.utils.system import SystemUtils

def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Система копирования файлов по возрасту",
        epilog="Пример: python CopyScript.py --max_age_days 3 --source_dir D:/input --dest_dir D:/output --shutdown 60"
    )
    parser.add_argument(
        "--max_age_days", "--days",
        type=int,
        help=f"Максимальный возраст файлов в днях (по умолчанию: {SCRIPT_CONFIG['MAX_AGE_DAYS']})"
    )
    parser.add_argument(
        "--conflict_mode",
        type=str,
        choices=["skip", "rename"],
        help=f"Стратегия разрешения конфликтов: skip или rename (по умолчанию: {SCRIPT_CONFIG['ON_CONFLICT']})"
    )
    parser.add_argument(
        "--source_dir",
        type=str,
        help=f"Исходная директория для копирования (по умолчанию: {SCRIPT_CONFIG['INPUT_DIR']})"
    )
    parser.add_argument(
        "--dest_dir",
        type=str,
        help=f"Целевая директория для копирования (по умолчанию: {SCRIPT_CONFIG['OUTPUT_DIR']})"
    )    
    parser.add_argument(
        "--detailed_logs",
        dest="detailed_logs",
        action="store_true",
        help="Включить детализированные логи"
    )
    parser.add_argument(
        "--no-detailed_logs",
        dest="detailed_logs",
        action="store_false",
        help="Отключить детализированные логи"
    )
    parser.set_defaults(detailed_logs=None)
    parser.add_argument(
        "--shutdown",
        nargs='?',
        const=True,
        default=False,
        type=int,
        help="Выключить компьютер после копирования (можно указать паузу в минутах, например --shutdown 10)"
    )
    return parser.parse_args()

def main() -> None:
    """
    Главная функция управления workflow скрипта.

    Этапы выполнения:
      1. Парсинг аргументов командной строки.
      2. Настройка глобального логирования через configure_logger из utils.py.
      3. Валидация и подготовка необходимых директорий (исходной, целевой и логовой).
      4. Выполнение операций копирования и логирование результатов.
      5. Выключение компьютера (если указано).
      6. Обработка исключений с критическим завершением при ошибке.
    """    
    # 1. Парсинг аргументов командной строки.
    args = parse_arguments()
    
    # Устанавливаем параметры. Приоритет: аргументы командной строки > конфиг сценария.
    max_age_days = args.max_age_days if args.max_age_days is not None else SCRIPT_CONFIG["MAX_AGE_DAYS"]
    conflict_mode = args.conflict_mode if args.conflict_mode is not None else SCRIPT_CONFIG["ON_CONFLICT"]
    if args.detailed_logs is not None:
        detailed_logs = args.detailed_logs
    else:
        detailed_logs = SCRIPT_CONFIG["DETAILED_LOGS"]
    input_dir = args.source_dir if args.source_dir else SCRIPT_CONFIG["INPUT_DIR"]
    output_dir = args.dest_dir if args.dest_dir else SCRIPT_CONFIG["OUTPUT_DIR"]

    user = SCRIPT_CONFIG.get("USER", "operator")
    task_name = SCRIPT_CONFIG.get("TASK_NAME", "CopyScript")
    
    # 2. Настройка логирования
    logger = configure_logger(
        user=user,
        task_name=task_name,
        detailed=detailed_logs
    )

    try:
        # 3. Валидация и подготовка директорий
        source_dir = FileSystemUtils.validate_readable_path(Path(input_dir))
        dest_dir = FileSystemUtils.validate_writable_path(Path(output_dir))

        if not source_dir:
            logger.critical(f"Исходная директория недоступна для чтения: {input_dir}")
            sys.exit(1)
        if not dest_dir:
            logger.critical(f"Целевая директория недоступна для записи: {output_dir}")
            sys.exit(1)

        logger.info("Старт копирования: %s -> %s (Порог: %s дней)", 
                    source_dir, dest_dir, max_age_days)
        
        # 4. Выполнение операций копирования и логирование результатов.
        file_result = copy_recent_files(
            src=source_dir,
            dst=dest_dir,
            days_threshold=max_age_days,
            conflict_mode=conflict_mode,
            logger=logger
        )

        logger.info("Файлов скопировано: %d, Ошибок: %d",
                    file_result.get('CopiedFiles', 0),
                    file_result.get('FileCopyingErrors', 0))
        
        # 5. Выключение компьютера (если указано) после завершения копирования.
        if args.shutdown:
            if isinstance(args.shutdown, int):
                pause_seconds = args.shutdown * 60
                logger.info("Пауза перед выключением: %d минут", args.shutdown)
                time.sleep(pause_seconds)
            logger.warning("Инициируется выключение компьютера")
            SystemUtils.shutdown_computer(logger=logger, force=False)

    # 6. Обработка исключений с критическим завершением при ошибке.
    except Exception as e:
        logger.critical("Критическая ошибка: %s", str(e), exc_info=True)
        sys.exit(1)
    finally:
        logger.info("Процедура копирования завершена")

if __name__ == "__main__":
    main()

# Содержимое файла: scheduler_runner\tasks\cameras\tests\test_cleanup_script.py
"""
Юнит-тесты для скрипта CleanupScript задачи cameras.

Покрытие:
    - Проверка получения конфигурации сценария (get_scenario_config)
    - Проверка удаления старых файлов и пустых папок (execute_cleanup_operations)
    - Проверка обработки ошибок
    - Использование временных директорий для изоляции тестов

Запуск:
    pytest scheduler_runner/tasks/cameras/tests/test_cleanup_script.py

Author: anikinjura
"""

from unittest import mock
import pytest
import logging
import os
from pathlib import Path

from scheduler_runner.tasks.cameras.CleanupScript import (
    get_scenario_config,
    execute_cleanup_operations,
)

@pytest.fixture
def temp_dir(tmp_path):
    """
    Создаёт временную директорию с файлами разного возраста и вложенными папками.
    """
    d = tmp_path / "test_cleanup"
    d.mkdir()
    # Старый файл (mtime = 1)
    old_file = d / "old_file.txt"
    old_file.write_text("old")
    os.utime(old_file, (1, 1))
    # Новый файл (mtime = сейчас)
    new_file = d / "new_file.txt"
    new_file.write_text("new")
    # Пустая папка
    empty_folder = d / "empty_folder"
    empty_folder.mkdir()
    # Папка с файлом
    non_empty_folder = d / "non_empty_folder"
    non_empty_folder.mkdir()
    (non_empty_folder / "file.txt").write_text("data")
    return d

def test_get_scenario_config_valid():
    """
    Проверяет, что get_scenario_config возвращает корректный конфиг для существующего сценария.
    """
    config = get_scenario_config("local")
    assert "CLEANUP_DIR" in config
    assert "MAX_AGE_DAYS" in config
    assert "DETAILED_LOGS" in config

def test_get_scenario_config_invalid():
    """
    Проверяет, что get_scenario_config выбрасывает ValueError для несуществующего сценария.
    """
    with pytest.raises(ValueError):
        get_scenario_config("unknown")

def test_execute_cleanup_operations_removes_old_files_and_empty_folders(temp_dir):
    """
    Проверяет, что execute_cleanup_operations удаляет старые файлы и пустые папки.
    """
    logger = logging.getLogger("test_cleanup")
    # MAX_AGE_DAYS = 0, удалит только old_file.txt (mtime=1)
    execute_cleanup_operations(logger, temp_dir, max_age_days=0)
    files = [f.name for f in temp_dir.iterdir()]
    assert "new_file.txt" in files
    assert "old_file.txt" not in files
    assert "empty_folder" not in files  # пустая папка должна быть удалена
    assert "non_empty_folder" in files  # не пустая папка должна остаться

def test_execute_cleanup_operations_handles_errors(tmp_path, caplog):
    """
    Проверяет, что ошибки при удалении файлов корректно логируются.
    """
    d = tmp_path / "test_cleanup"
    d.mkdir()
    error_file = d / "error.txt"
    error_file.write_text("fail")
    # Сделаем файл очень старым, чтобы он точно попал под удаление
    os.utime(error_file, (1, 1))

    logger = logging.getLogger("test_cleanup_error")

    def unlink_side_effect(self, *args, **kwargs):
        if self.name == "error.txt":
            raise PermissionError("Mocked permission error")
        return original_unlink(self, *args, **kwargs)

    original_unlink = Path.unlink

    with mock.patch("pathlib.Path.unlink", new=unlink_side_effect):
        with caplog.at_level(logging.WARNING):
            execute_cleanup_operations(logger, d, max_age_days=0)
            assert "Ошибка при удалении файла" in caplog.text

# Содержимое файла: scheduler_runner\tasks\cameras\tests\test_cloud_monitor_script.py
import pytest
from unittest.mock import MagicMock, patch
from pathlib import Path

import scheduler_runner.tasks.cameras.CloudMonitorScript as cms

@pytest.fixture
def logger():
    return MagicMock()

def test_cloud_accessibility_success(tmp_path, logger):
    # tmp_path — временная директория pytest
    result, msg = cms.test_cloud_accessibility(tmp_path, logger)
    assert result is True
    assert msg == "Успешно"
    logger.info.assert_called_with("Проверка доступности облачного хранилища: Успешно")

def test_cloud_accessibility_no_dir(logger):
    fake_dir = Path("Z:/nonexistent_dir_12345")
    result, msg = cms.test_cloud_accessibility(fake_dir, logger)
    assert result is False
    assert "не существует" in msg
    logger.warning.assert_called()

def test_cloud_accessibility_not_a_dir(tmp_path, logger):
    file_path = tmp_path / "file.txt"
    file_path.write_text("test")
    result, msg = cms.test_cloud_accessibility(file_path, logger)
    assert result is False
    assert "не является директорией" in msg
    logger.error.assert_called()

@patch("scheduler_runner.tasks.cameras.CloudMonitorScript.send_telegram_message")
def test_send_notification_success(mock_send, logger):
    mock_send.return_value = (True, "ok")
    cms.SCRIPT_CONFIG["TOKEN"] = "token"
    cms.SCRIPT_CONFIG["CHAT_ID"] = "chat"
    result = cms.send_notification("msg", logger)
    assert result is True
    logger.info.assert_called_with("Уведомление успешно отправлено через Telegram")

@patch("scheduler_runner.tasks.cameras.CloudMonitorScript.send_telegram_message")
def test_send_notification_fail(mock_send, logger):
    mock_send.return_value = (False, "fail")
    cms.SCRIPT_CONFIG["TOKEN"] = "token"
    cms.SCRIPT_CONFIG["CHAT_ID"] = "chat"
    result = cms.send_notification("msg", logger)
    assert result is False
    logger.error.assert_called()

def test_send_notification_no_token(logger):
    cms.SCRIPT_CONFIG["TOKEN"] = ""
    cms.SCRIPT_CONFIG["CHAT_ID"] = ""
    result = cms.send_notification("msg", logger)
    assert result is False
    logger.warning.assert_called_with("Параметры Telegram не заданы, уведомление не отправлено")

# Содержимое файла: scheduler_runner\tasks\cameras\tests\test_copy_script.py
import pytest
import logging
import os
from pathlib import Path
from unittest import mock

from scheduler_runner.tasks.cameras.CopyScript import main as copy_main
from scheduler_runner.utils.filesystem import copy_recent_files

@pytest.fixture
def temp_dirs(tmp_path):
    src = tmp_path / "src"
    dst = tmp_path / "dst"
    src.mkdir()
    dst.mkdir()
    # Старый файл (не должен копироваться)
    old_file = src / "old.txt"
    old_file.write_text("old")
    os.utime(old_file, (1, 1))
    # Новый файл (должен копироваться)
    new_file = src / "new.txt"
    new_file.write_text("new")
    return src, dst

def test_copy_recent_files_skip(temp_dirs):
    src, dst = temp_dirs
    # Создаём файл-конфликт в dst
    conflict_file = dst / "new.txt"
    conflict_file.write_text("conflict")
    logger = logging.getLogger("test_copy_skip")
    result = copy_recent_files(
        src=src,
        dst=dst,
        days_threshold=10000,
        conflict_mode="skip",
        logger=logger
    )
    # Файл не должен быть перезаписан
    assert (dst / "new.txt").read_text() == "conflict"
    assert result["CopiedFiles"] == 0 or result["CopiedFiles"] == 1  # зависит от времени создания

def test_copy_recent_files_rename(temp_dirs):
    src, dst = temp_dirs
    # Создаём файл-конфликт в dst
    conflict_file = dst / "new.txt"
    conflict_file.write_text("conflict")
    logger = logging.getLogger("test_copy_rename")
    result = copy_recent_files(
        src=src,
        dst=dst,
        days_threshold=10000,
        conflict_mode="rename",
        logger=logger
    )
    # Оригинальный конфликтный файл должен остаться, новый файл с суффиксом должен появиться
    assert (dst / "new.txt").read_text() == "conflict"
    renamed = list(dst.glob("new_*.txt"))
    assert renamed
    assert any("new" in f.name for f in renamed)
    assert result["CopiedFiles"] >= 1

def test_copy_recent_files_invalid_conflict_mode(temp_dirs):
    src, dst = temp_dirs
    logger = logging.getLogger("test_copy_invalid")
    with pytest.raises(ValueError):
        copy_recent_files(
            src=src,
            dst=dst,
            days_threshold=10000,
            conflict_mode="overwrite",  # не поддерживается
            logger=logger
        )

def test_main_with_invalid_dirs(monkeypatch):
    # Проверяем, что main завершится с sys.exit(1) при невалидных директориях
    import sys
    from scheduler_runner.tasks.cameras import CopyScript

    test_args = [
        "CopyScript.py",
        "--source_dir", "Z:/not_exists",
        "--dest_dir", "Z:/not_exists2"
    ]
    monkeypatch.setattr(sys, "argv", test_args)
    with pytest.raises(SystemExit) as e:
        CopyScript.main()
    assert e.value.code == 1

def test_main_with_shutdown(monkeypatch, tmp_path):
    """
    Проверяет, что при передаче --shutdown вызывается SystemUtils.shutdown_computer.
    """
    import sys
    from scheduler_runner.tasks.cameras import CopyScript

    # Создаём временные директории для теста
    src = tmp_path / "src"
    dst = tmp_path / "dst"
    src.mkdir()
    dst.mkdir()
    (src / "file.txt").write_text("data")

    # Подменяем sys.argv для передачи аргументов
    test_args = [
        "CopyScript.py",
        "--source_dir", str(src),
        "--dest_dir", str(dst),
        "--shutdown"
    ]
    monkeypatch.setattr(sys, "argv", test_args)

    # Мокаем функцию shutdown_computer
    called = {}

    def fake_shutdown_computer(logger, force):
        called["shutdown"] = True

    monkeypatch.setattr(CopyScript.SystemUtils, "shutdown_computer", fake_shutdown_computer)

    # Запускаем main
    CopyScript.main()

    assert called.get("shutdown") is True

# Содержимое файла: scheduler_runner\tasks\cameras\tests\test_videomonitor_script.py
import sys
import pytest
from datetime import datetime

import scheduler_runner.tasks.cameras.VideoMonitorScript as vms

@pytest.fixture
def fake_logger():
    class Logger:
        def __init__(self):
            self.messages = []
        def info(self, msg, *a, **k): self.messages.append(("info", msg))
        def warning(self, msg, *a, **k): self.messages.append(("warning", msg))
        def error(self, msg, *a, **k): self.messages.append(("error", msg))
    return Logger()

def make_cam(uid, cam_id):
    return {"uid": uid, "id": cam_id}

def test_has_recent_records_found(tmp_path, fake_logger):
    # Создаём структуру для UNV камеры: .../unv_camera/uid/YYYYMMDD/HH
    now = datetime.now()
    uid = "cam1"
    root = tmp_path
    date = now.strftime("%Y%m%d")
    hour = now.strftime("%H")
    rec_dir = root / "unv_camera" / uid / date / hour
    rec_dir.mkdir(parents=True)
    (rec_dir / "file1.mp4").write_text("data")
    assert vms.has_recent_records(
        root, uid, min_files=1, max_lookback_hours=2,
        path_builder=vms.unv_path_builder, logger=fake_logger, camera_type="UNV"
    )

def test_has_recent_records_not_found(tmp_path, fake_logger):
    # Нет ни одной папки с файлами
    now = datetime.now()
    uid = "cam2"
    root = tmp_path
    assert not vms.has_recent_records(
        root, uid, min_files=1, max_lookback_hours=2,
        path_builder=vms.unv_path_builder, logger=fake_logger, camera_type="UNV"
    )

def test_main_all_cameras_ok(monkeypatch, tmp_path):
    # Подготовка: одна UNV и одна Xiaomi камера, у обеих есть записи
    now = datetime.now()
    uid1, uid2 = "unv1", "xiaomi1"
    date = now.strftime("%Y%m%d")
    hour = now.strftime("%H")
    dt = now.strftime("%Y%m%d%H")
    # UNV
    unv_dir = tmp_path / "unv_camera" / uid1 / date / hour
    unv_dir.mkdir(parents=True)
    (unv_dir / "f.mp4").write_text("x")
    # Xiaomi
    xiaomi_dir = tmp_path / "xiaomi_camera_videos" / uid2 / dt
    xiaomi_dir.mkdir(parents=True)
    (xiaomi_dir / "f.mp4").write_text("x")

    # Переопределяем SCRIPT_CONFIG для теста
    test_config = {
        "CAMERAS": {"test": [make_cam(uid1, "unv1"), make_cam(uid2, "xiaomi1")]},
        "TOKEN": "t", "CHAT_ID": "c",
        "local": {
            "CHECK_DIR": str(tmp_path),
            "MAX_LOOKBACK_HOURS": 2,
            "DETAILED_LOGS": False,
            "USER": "test",
            "TASK_NAME": "VideoMonitorScript_local"
        }
    }
    monkeypatch.setattr(vms, "SCRIPT_CONFIG", test_config)

    # Мокаем send_telegram_message чтобы не отправлять настоящие уведомления
    monkeypatch.setattr(vms, "send_telegram_message", lambda token, chat_id, msg, logger: (True, "ok"))

    # Мокаем configure_logger чтобы не писать в файл
    class DummyLogger:
        def info(self, *a, **k): pass
        def warning(self, *a, **k): pass
        def error(self, *a, **k): pass
    monkeypatch.setattr(vms, "configure_logger", lambda **kwargs: DummyLogger())

    # Мокаем sys.argv
    monkeypatch.setattr(sys, "argv", ["VideoMonitorScript.py", "--check_type", "local"])

    # Должно пройти без ошибок и не вызвать send_telegram_message с предупреждением
    vms.main()

def test_main_missing_records(monkeypatch, tmp_path):
    # Камера без записей, должен быть вызов send_telegram_message
    uid1 = "unv2"
    test_config = {
        "CAMERAS": {"test": [make_cam(uid1, "unv2")]},
        "TOKEN": "t", "CHAT_ID": "c",
        "local": {
            "CHECK_DIR": str(tmp_path),
            "MAX_LOOKBACK_HOURS": 2,
            "DETAILED_LOGS": False,
            "USER": "test",
            "TASK_NAME": "VideoMonitorScript_local"
        }
    }
    monkeypatch.setattr(vms, "SCRIPT_CONFIG", test_config)
    called = {}
    def fake_send(token, chat_id, msg, logger):
        called["sent"] = msg
        return True, "ok"
    monkeypatch.setattr(vms, "send_telegram_message", fake_send)
    monkeypatch.setattr(vms, "configure_logger", lambda **kwargs: type("L", (), {"info": lambda *a, **k: None, "warning": lambda *a, **k: None, "error": lambda *a, **k: None})())
    monkeypatch.setattr(sys, "argv", ["VideoMonitorScript.py", "--check_type", "local"])
    vms.main()
    assert "отсутствуют записи" in called["sent"]

def test_main_no_cameras(monkeypatch):
    # Нет камер — должен быть sys.exit(1)
    test_config = {
        "CAMERAS": {},
        "TOKEN": "t", "CHAT_ID": "c",
        "local": {
            "CHECK_DIR": ".",
            "MAX_LOOKBACK_HOURS": 2,
            "DETAILED_LOGS": False,
            "USER": "test",
            "TASK_NAME": "VideoMonitorScript_local"
        }
    }
    monkeypatch.setattr(vms, "SCRIPT_CONFIG", test_config)
    monkeypatch.setattr(vms, "configure_logger", lambda **kwargs: type("L", (), {"info": lambda *a, **k: None, "warning": lambda *a, **k: None, "error": lambda *a, **k: None})())
    monkeypatch.setattr(sys, "argv", ["VideoMonitorScript.py", "--check_type", "local"])
    with pytest.raises(SystemExit) as e:
        vms.main()
    assert e.value.code == 1

# Содержимое файла: scheduler_runner\tasks\cameras\VideoMonitorScript.py
"""
VideoMonitorScript.py

Скрипт для мониторинга наличия видеозаписей с камер видеонаблюдения.

Основной функционал:
- Локальная проверка: по каждому uid камеры ищет записи за последние N часов (N задаётся в конфиге) в локальной директории.
- Облачная проверка: по каждому uid камеры ищет записи за последние N часов (N задаётся в конфиге) в облачной директории.
- Если для какой-либо камеры не найдено нужного количества файлов ни в одном из последних N часов — формируется уведомление.
- Уведомления отправляются через утилиту ядра notify.py (Telegram).

Архитектура:
- Все параметры (пути, список камер, параметры Telegram, глубина проверки) задаются в cameras/config/scripts/videomonitor_config.py.
- Логика поиска записей за последние N часов вынесена в универсальную функцию has_recent_records.
- Для разных типов камер (UNV, Xiaomi) используется свой path_builder для построения пути к папке с записями.
- Скрипт поддерживает детализированные логи и параметр --min_files для задания минимального количества файлов.

Пример использования:
    python VideoMonitorScript.py --check_type local --detailed_logs --min_files 2

Author: anikinjura
"""
__version__ = '0.0.2'

from typing import Callable
import argparse
import logging
import sys
from pathlib import Path
from datetime import datetime, timedelta

from scheduler_runner.tasks.cameras.config.scripts.videomonitor_config import SCRIPT_CONFIG
from scheduler_runner.utils.logging import configure_logger
from scheduler_runner.utils.notify import send_telegram_message

def parse_arguments() -> argparse.Namespace:
    """
    Парсит аргументы командной строки для скрипта мониторинга видеозаписей.

    --check_type local|network   - сценарий проверки (локально или в облаке)
    --detailed_logs              - включить детализированные логи
    --min_files N                - минимальное количество файлов для успешной проверки (по умолчанию 1)
    """
    parser = argparse.ArgumentParser(
        description="Мониторинг видеозаписей с камер",
        epilog="Пример: python VideoMonitorScript.py --check_type local --detailed_logs --min_files 2"
    )
    parser.add_argument(
        "--check_type",
        type=str,
        choices=["local", "network"],
        required=True,
        help="Тип проверки: local или network"
    )
    parser.add_argument(
        "--detailed_logs",
        action="store_true",
        default=False,
        help="Включить детализированные логи"
    )
    parser.add_argument(
        "--min_files",
        type=int,
        default=1,
        help="Минимальное количество файлов для успешной проверки"
    )
    return parser.parse_args()

def has_recent_records(
    root_dir: Path,
    uid: str,
    min_files: int,
    max_lookback_hours: int,
    path_builder: Callable[[Path, str, datetime], Path],
    logger: logging.Logger,
    camera_type: str
) -> bool:
    """
    Проверяет наличие записей за последние max_lookback_hours часов для камеры с заданным uid.

    Аргументы:
        root_dir: Корневая директория для поиска записей.
        uid: Уникальный идентификатор камеры.
        min_files: Минимальное количество файлов для успешной проверки.
        max_lookback_hours: Глубина проверки в часах (например, 2 — текущий и предыдущий час).
        path_builder: Функция, формирующая путь к папке с записями по типу камеры.
        logger: Логгер для записи информации.
        camera_type: Строка для логов ("UNV" или "Xiaomi").

    Возвращает:
        True, если записи найдены хотя бы за один из последних max_lookback_hours часов, иначе False.
    """
    now = datetime.now()
    for delta in range(0, max_lookback_hours):
        check_time = now - timedelta(hours=delta)
        path = path_builder(root_dir, uid, check_time)
        # Проверяем наличие папки и достаточного количества файлов
        if path.exists() and sum(1 for _ in path.iterdir()) >= min_files:
            if delta == 0:
                logger.info(f"{camera_type} камера {uid}: найдены записи за текущий час ({check_time.strftime('%H')})")
            else:
                logger.info(f"{camera_type} камера {uid}: найдены записи за {delta}-й час назад ({check_time.strftime('%H')})")
            return True
    logger.warning(f"{camera_type} камера {uid}: записи отсутствуют за последние {max_lookback_hours} часов")
    return False

def unv_path_builder(root_dir: Path, uid: str, check_time: datetime) -> Path:
    """
    Формирует путь к папке с записями UNV-камеры за указанный час.
    Пример: root_dir/unv_camera/uid/YYYYMMDD/HH
    """
    target_date = check_time.strftime("%Y%m%d")
    hour_str = check_time.strftime("%H")
    return root_dir / "unv_camera" / uid / target_date / hour_str

def xiaomi_path_builder(root_dir: Path, uid: str, check_time: datetime) -> Path:
    """
    Формирует путь к папке с записями Xiaomi-камеры за указанный час.
    Пример: root_dir/xiaomi_camera_videos/uid/YYYYMMDDHH
    """
    target_datetime = check_time.strftime("%Y%m%d%H")
    return root_dir / "xiaomi_camera_videos" / uid / target_datetime

def send_notification(message: str, logger: logging.Logger) -> bool:
    """
    Отправляет уведомление через утилиту ядра scheduler_runner/utils/notify.py.

    Аргументы:
        message: Текст уведомления.
        logger: Логгер для записи информации.
    Возвращает:
        True, если отправлено успешно, False в противном случае.
    """
    token = SCRIPT_CONFIG["TOKEN"]
    chat_id = SCRIPT_CONFIG["CHAT_ID"]
    if not token or not chat_id:
        logger.warning("Параметры Telegram не заданы, уведомление не отправлено")
        return False
    success, result = send_telegram_message(token, chat_id, message, logger)
    if success:
        logger.info("Уведомление успешно отправлено через Telegram")
    else:
        logger.error("Ошибка отправки уведомления через Telegram: %s", result)
    return success

def main() -> None:
    """
    Основная функция скрипта мониторинга видеозаписей.

    Этапы:
    1. Разбор аргументов командной строки.
    2. Настройка логирования.
    3. Получение конфигурации камер и параметров сценария.
    4. Для каждой камеры строится путь к папке с записями и ищутся записи за последние N часов.
    5. Если хотя бы для одной камеры не найдено нужного количества файлов — отправляется уведомление.
    """
    args = parse_arguments()
    scenario = args.check_type
    scenario_config = SCRIPT_CONFIG[scenario]
    max_lookback_hours = scenario_config.get("MAX_LOOKBACK_HOURS", 2)
    cameras = SCRIPT_CONFIG["CAMERAS"]

    # Настройка логгера с учётом сценария и детализированности
    logger = configure_logger(
        user=scenario_config["USER"],
        task_name=scenario_config["TASK_NAME"],
        detailed=args.detailed_logs if args.detailed_logs is not None else scenario_config["DETAILED_LOGS"]
    )

    if not cameras:
        logger.error("Конфигурация камер недоступна или PVZ_ID не найден.")
        sys.exit(1)

    root_dir = Path(scenario_config["CHECK_DIR"])
    missing_records = []

    # Основной цикл по всем камерам
    for area, cam_list in cameras.items():
        for cam in cam_list:
            uid = cam["uid"]
            cam_id = cam["id"]
            # Для UNV-камер используем unv_path_builder, для Xiaomi — xiaomi_path_builder
            if cam_id.startswith("unv"):
                if not has_recent_records(root_dir, uid, args.min_files, max_lookback_hours, unv_path_builder, logger, "UNV"):
                    missing_records.append(f"{cam_id} ({area})")
            elif cam_id.startswith("xiaomi"):
                if not has_recent_records(root_dir, uid, args.min_files, max_lookback_hours, xiaomi_path_builder, logger, "Xiaomi"):
                    missing_records.append(f"{cam_id} ({area})")

    # Если есть камеры без записей — отправляем уведомление
    if missing_records:
        check_type_str = "на компьютере" if scenario == "local" else "в облаке"
        message = f"ПВЗ: {SCRIPT_CONFIG.get('PVZ_ID', '-')}, {check_type_str} отсутствуют записи для камер: {', '.join(missing_records)}"
        send_notification(message, logger)
        logger.warning(message)
    else:
        logger.info("Все камеры имеют записи за проверяемый период.")

if __name__ == "__main__":
    main()

# Содержимое файла: scheduler_runner\runner.py
"""
Основной модуль планировщика задач.

Этот модуль является точкой входа для системы планирования и выполнения задач.
Запускается Windows Task Scheduler с параметрами командной строки для фильтрации
и выполнения задач по расписанию или принудительно.

Пример запуска:
    pythonw runner.py --user operator
    pythonw runner.py --user admin --task BackupDB --detailed_logs

Модуль выполняет следующие функции:
    - Парсинг аргументов командной строки
    - Загрузка и фильтрация конфигурации задач (task)
        1. В каждом домене (например, cameras, system) в файлах /tasks/домен/config/scripts/*_config.py формируется список задач SCHEDULE (или TASK_SCHEDULE).
        2. Эти списки объединяются в соответствующем /tasks/домен/config/*_schedule.py, экспортируя общий список задач домена.
        3. Глобальный список задач SCHEDULE формируется в schedule_config.py через функцию _discover_task_configs(), которая импортирует все доменные расписания.
        4. В ядре (runner.py) задачи фильтруются по пользователю и имени, и передаются в функцию execute_task для запуска.
    - Проверка расписания выполнения
    - Запуск задач в подпроцессах с контролем окружения
    - Логирование результатов выполнения

Author: anikinjura
"""
__version__ = '0.0.2'

import argparse
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any

try:
    from scheduler_runner.schedule_config import SCHEDULE, get_task_env
    from scheduler_runner.utils.logging import configure_logger
    from scheduler_runner.utils.timing import should_run_now
    from scheduler_runner.utils.subprocess import run_subprocess
    from config.base_config import PATH_CONFIG
except ImportError as e:
    print(f"Критическая ошибка импорта: {e}")
    print("Проверьте структуру проекта и наличие всех модулей")
    sys.exit(3)


def parse_arguments() -> argparse.Namespace:
    """
    Парсит аргументы командной строки для планировщика задач.
    
    Функция создает парсер аргументов командной строки с поддержкой следующих параметров:
    - --user: обязательный параметр для указания системного пользователя
    - --task: опциональный параметр для принудительного запуска конкретной задачи
    - --detailed_logs: флаг включения детального логирования на уровне DEBUG
    
    Returns:
        argparse.Namespace: объект с распарсенными аргументами командной строки
        
    Raises:
        SystemExit: если переданы некорректные аргументы или отсутствует --user
        
    Example:
        >>> args = parse_arguments()
        >>> print(args.user)
        'operator'
        >>> print(args.task)
        None
        >>> print(args.detailed_logs)
        False
    """
    parser = argparse.ArgumentParser(
        description="Планировщик выполнения задач по расписанию",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Примеры использования:
  %(prog)s --user operator                    # Запуск всех задач пользователя operator по расписанию
  %(prog)s --user admin --task BackupDB       # Принудительный запуск конкретной задачи BackupDB
  %(prog)s --user operator --detailed_logs    # Запуск с детальным логированием (DEBUG)
        """
    )
    
    parser.add_argument(
        '--user', 
        required=True, 
        help='Имя системного пользователя для фильтрации задач'
    )
    
    parser.add_argument(
        '--task', 
        help='Имя конкретной задачи для принудительного запуска (игнорирует расписание)'
    )
    
    parser.add_argument(
        '--detailed_logs', 
        action='store_true', 
        help='Включить детальное логирование на уровне DEBUG'
    )
    
    return parser.parse_args()


def filter_tasks(all_tasks: List[Dict[str, Any]], user: str, task_name: str | None = None) -> List[Dict[str, Any]]:
    """
    Фильтрует список задач по пользователю и опционально по имени задачи.
    
    Функция выполняет двухэтапную фильтрацию:
    1. Сначала отбирает все задачи для указанного пользователя
    2. Если указано имя задачи, дополнительно фильтрует по этому критерию
    
    Args:
        all_tasks: полный список задач из конфигурации планировщика
        user: имя пользователя для фильтрации задач
        task_name: опциональное имя конкретной задачи для дополнительной фильтрации
        
    Returns:
        List[Dict[str, Any]]: отфильтрованный список задач, соответствующих критериям
        
    Example:
        >>> tasks = [
        ...     {'name': 'backup', 'user': 'admin'},
        ...     {'name': 'cleanup', 'user': 'operator'},
        ...     {'name': 'monitor', 'user': 'operator'}
        ... ]
        >>> filtered = filter_tasks(tasks, 'operator')
        >>> len(filtered)
        2
        >>> filtered = filter_tasks(tasks, 'operator', 'cleanup')
        >>> len(filtered)
        1
    """
    # Приводим имя пользователя к нижнему регистру для унификации
    user_lower = user.lower()

    # Первый этап: фильтрация по пользователю (без учета регистра)
    user_tasks = [task for task in all_tasks if str(task.get('user', '')).lower() == user_lower]
    
    # Второй этап: дополнительная фильтрация по имени задачи (если задача указана, приводим её к нижнему регистру)
    if task_name:
        task_name_lower = task_name.lower()
        user_tasks = [task for task in user_tasks if str(task.get('name', '')).lower() == task_name_lower]
    
    return user_tasks

def sort_tasks_by_time(tasks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Сортирует задачи в порядке возрастания по полю 'time'.
    Если time отсутствует или некорректен, считается 0 минут.
    """    
    def _get_time(task: Dict[str, Any]) -> int:
        t = task.get('time')
        if isinstance(t, str) and ':' in t:
            try:
                h, m = map(int, t.split(':', 1))
                return h * 60 + m
            except ValueError:
                return 0
        return 0
    return sorted(tasks, key=_get_time)

def execute_task(task: Dict[str, Any], logger, force_run: bool = False, detailed_logs: bool = False) -> bool:
    """
    Выполняет отдельную задачу с проверкой расписания и контролем процесса.
    
    Функция выполняет следующие операции:
    1. Проверяет расписание выполнения (если не принудительный запуск)
    2. Определяет модуль/скрипт для запуска
    3. Подготавливает параметры запуска и переменные окружения
    4. Запускает задачу в подпроцессе с контролем времени выполнения
    5. Логирует результат выполнения
    
    Args:
        task: словарь с конфигурацией задачи, содержащий поля:
            - name: имя задачи
            - module/script: модуль или скрипт для запуска
            - args: список аргументов командной строки
            - timeout: максимальное время выполнения в секундах
            - schedule: конфигурация расписания
        logger: настроенный логгер для записи событий выполнения
        force_run: флаг принудительного запуска без проверки расписания
        detailed_logs: флаг передачи детализированного логирования в подпроцесс

    Returns:
        bool: True если задача выполнена успешно, False в случае ошибки
        
    Raises:
        ValueError: если конфигурация расписания задачи некорректна
        
    Example:
        >>> task = {
        ...     'name': 'backup_db',
        ...     'module': 'backup_script',
        ...     'args': ['--full'],
        ...     'timeout': 300,
        ...     'schedule': 'daily',
        ...     'time': '02:00'
        ... }
        >>> success = execute_task(task, logger, force_run=True)
        >>> print(success)
        True
    """
    task_name = task.get('name', 'Unknown')
    schedule_type = task.get('schedule')

    # Определяем, нужно ли запускать задачу
    if force_run:
        should_run = True
        logger.info(f"Старт задачи '{task_name}' (force_run={force_run})")
    else:
        try:
            should_run = should_run_now(task, datetime.now())
        except ValueError as e:
            logger.error(f"Ошибка в конфиге расписания '{task_name}': {e}")
            return False
        except Exception as e:
            logger.error(f"Ошибка проверки расписания '{task_name}': {e}")
            return False
        if not should_run:
            logger.info(f"Задача '{task_name}' не должна запускаться сейчас по расписанию")
            return False # TODO: возможно, стоит вернуть True, если задача уже выполнена
        # логируем старт
        logger.info(f"Старт задачи '{task_name}' (force_run={force_run})")
    
    # Определяем модуль для запуска (приоритет: module > script > name)
    script_module = task.get('module') or task.get('script') or task_name
    
    # Подготавливаем параметры запуска
    args_list = list(task.get('args', []))  # Копируем список аргументов, чтобы не менять оригинал
    # Если detailed_logs=True и '--detailed_logs' ещё не передан, добавляем его к аргументам подпроцесса
    if detailed_logs and '--detailed_logs' not in args_list:
        args_list.append('--detailed_logs')

    env_vars = get_task_env(task)
    timeout_seconds = task.get('timeout', 60)

    # Получаем путь к директории задач
    working_directory = str(PATH_CONFIG['TASKS_ROOT'])

    # Логируем параметры запуска
    logger.info(f"Запуск модуля '{script_module}' с аргументами: {args_list}")
    if logger.isEnabledFor(10):  # DEBUG level
        logger.debug(f"Переменные окружения: {list(env_vars.keys())}")
        logger.debug(f"Рабочая директория: {working_directory}")
        logger.debug(f"Таймаут: {timeout_seconds} сек")
    
    # Выполняем задачу в подпроцессе
    try:
        now = datetime.now()
        if schedule_type in ('daily', 'hourly'):
            window = now.strftime('%Y-%m-%d_%H')
        else:
            window = now.strftime('%Y-%m-%d_%H-%M')

        success = run_subprocess(
            script_name=script_module,
            args=args_list,
            env=env_vars,
            logger=logger,
            timeout=timeout_seconds,
            working_dir=working_directory,
            schedule_type=schedule_type,
            window=window            
        )
    except Exception as e:
        logger.exception(f"Ошибка при запуске подпроцесса для '{task_name}': {e}")
        return False
    
    # Логируем результат
    if success:
        logger.info(f"Задача '{task_name}' успешно завершена")
        return True
    else:
        logger.error(f"Задача '{task_name}' завершилась с ошибкой")
        return False


def main() -> None:
    """
    Основная функция приложения - точка входа планировщика задач.
    
    Функция выполняет полный цикл работы планировщика:
    1. Парсит аргументы командной строки
    2. Фильтрует задачи по пользователю и имени
    3. Проверяет наличие задач для выполнения
    4. Запускает каждую задачу с индивидуальным логированием
    5. Подсчитывает статистику выполнения
    6. Устанавливает код завершения процесса
    
    Exit Codes:
        0: все задачи выполнены успешно
        1: одна или несколько задач завершились с ошибкой
        2: выполнение прервано пользователем (Ctrl+C)
        3: критическая ошибка приложения
        
    Raises:
        KeyboardInterrupt: при прерывании выполнения пользователем
        Exception: при критических ошибках приложения
        
    Example:
        При запуске с аргументами --user operator --detailed_logs:
        1. Загружает все задачи для пользователя 'operator'
        2. Проверяет расписание каждой задачи
        3. Запускает задачи с детальным логированием
        4. Выводит итоговую статистику
    """
    try:
        # Парсим аргументы командной строки
        args = parse_arguments()

        # Проверяем доступность конфигурации
        if not SCHEDULE:
            print("Конфигурация расписания пуста или не загружена")
            sys.exit(3)

        # Фильтруем задачи по пользователю и имени задачи            
        tasks_to_run = filter_tasks(SCHEDULE, args.user, args.task)
        
        # Сортируем задачи по возрастанию времени выполнения
        tasks_to_run = sort_tasks_by_time(tasks_to_run)

        # Проверяем наличие задач для выполнения
        if not tasks_to_run:
            if args.task:
                print(f"Задача '{args.task}' для пользователя '{args.user}' не найдена")
            else:
                print(f"Нет задач для пользователя '{args.user}'")
            sys.exit(2)
        
        # Выводим информацию о найденных задачах
        task_count = len(tasks_to_run)
        print(f"Найдено {task_count} задач(и) для выполнения")

        # Инициализируем счетчики успешных и неудачных выполнений
        successful_tasks = 0
        failed_tasks = 0       
        
        # Выполняем каждую задачу
        for task in tasks_to_run:
            # Настраиваем индивидуальный логгер для каждой задачи
            try:
                logger = configure_logger(
                    user=args.user,
                    task_name=task.get('name'),
                    detailed=args.detailed_logs
                )
            except Exception as e:
                print(f"Ошибка настройки логгера для задачи {task.get('name', 'Unknown')}: {e}")
                failed_tasks += 1
                continue
            
            try:
                # Выполняем задачу
                if execute_task(task, logger, force_run=bool(args.task), detailed_logs=args.detailed_logs):
                    successful_tasks += 1
                else:
                    failed_tasks += 1
            except Exception as e:
                # Логируем неожиданные ошибки выполнения
                task_name = task.get('name', 'Unknown')
                logger.exception(f"Неожиданная ошибка при выполнении задачи '{task_name}': {e}")
                failed_tasks += 1
        
        # Выводим итоговую статистику
        print(f"Выполнение завершено: {successful_tasks} успешно, {failed_tasks} с ошибками")
        
        # Устанавливаем код завершения в зависимости от результатов
        if failed_tasks > 0:
            sys.exit(1)
        sys.exit(0)

    except KeyboardInterrupt:
        print("Выполнение прервано пользователем")
        sys.exit(2)
        
    except Exception as e:
        print(f"Критическая ошибка: {e}")
        sys.exit(3)


if __name__ == '__main__':
    main()

# Содержимое файла: scheduler_runner\schedule_config.py
"""
Модуль конфигурации расписания задач.

Этот модуль отвечает за автоматическое обнаружение, загрузку и валидацию
конфигураций задач из доменных подпакетов в директории tasks/.

Модуль выполняет следующие функции:
    - Автоматическое обнаружение конфигураций задач в подпапках
    - Динамическая загрузка модулей конфигурации
    - Валидация структуры и содержимого конфигураций
    - Объединение переменных окружения для задач
    - Предоставление централизованного доступа к расписанию

Структура конфигурации задачи:
    {
        'name': 'имя_задачи',
        'user': 'системный_пользователь',
        'module': 'модуль_для_запуска',
        'schedule': 'daily' | 'hourly' | 'interval',
        'time': 'HH:MM',  # для daily
        'args': ['arg1', 'arg2'],
        'timeout': 300,
        'env': {'KEY': 'value'}
    }

Author: anikinjura
"""
__version__ = '0.0.1'

from typing import List, Dict, Any, Optional
from pathlib import Path
import sys
import importlib

# Импортируем базовую конфигурацию
from config.base_config import PATH_CONFIG

# Импортируем централизованную систему логирования
from scheduler_runner.utils.logging import configure_logger

# Настройка логирования для schedule_config
logger = configure_logger(
    user='system',
    task_name='schedule_config',
    detailed=True,
    logs_dir=str(PATH_CONFIG['LOGS_ROOT'])
)

# Переменные окружения по умолчанию для всех задач. Пути к директориям преобразуются в строки для совместимости
# с запуском в subprocess.
DEFAULT_TASK_ENV = {
    'BASE_DIR': str(PATH_CONFIG['BASE_DIR']),
    'SCHEDULER_ROOT': str(PATH_CONFIG['SCHEDULER_ROOT']),
    'LOGS_ROOT': str(PATH_CONFIG['LOGS_ROOT']),
    'TASKS_ROOT': str(PATH_CONFIG['TASKS_ROOT']),

    'LOG_LEVEL': 'INFO',
    'TASK_RUNNER': 'scheduler_runner',
}


def _discover_task_configs() -> List[Dict[str, Any]]:
    """
    Обнаруживает и загружает конфигурации задач из всех подпапок tasks.
    
    Функция сканирует директорию tasks/ в поисках подпапок с конфигурациями.
    Для каждой подпапки ищет файл config/{папка}_schedule.py и пытается
    импортировать переменные TASK_SCHEDULE или SCHEDULE.
    
    Структура поиска:
        scheduler_runner/tasks/
        ├── domain1/
        │   └── config/
        │       └── domain1_schedule.py  # содержит TASK_SCHEDULE или SCHEDULE
        └── domain2/
            └── config/
                └── domain2_schedule.py
    
    Returns:
        List[Dict[str, Any]]: список всех найденных и загруженных конфигураций задач
        
    Raises:
        ImportError: если не удается импортировать модуль конфигурации
        AttributeError: если в модуле отсутствуют ожидаемые переменные
        
    Example:
        >>> configs = _discover_task_configs()
        >>> len(configs)
        5
        >>> print(configs[0]['name'])
        'camera_cleanup'
    """
    tasks_schedule: List[Dict[str, Any]] = []

    # Определяем путь к директории tasks
    tasks_dir = Path(DEFAULT_TASK_ENV['TASKS_ROOT'])
    
    if not tasks_dir.exists():
        logger.warning(f"Директория задач не найдена: {tasks_dir}")
        return tasks_schedule
    
    logger.info(f"Поиск конфигураций задач в директории: {tasks_dir}")
    
    # Проходим по всем подпапкам в tasks
    for task_dir in tasks_dir.iterdir():
        # Пропускаем файлы и скрытые директории
        if not task_dir.is_dir() or task_dir.name.startswith('_'):
            continue
        # Формируем путь к конфигурационному файлу    
        config_file = task_dir / 'config' / f'{task_dir.name}_schedule.py'
        
        if not config_file.exists():
            logger.debug(f"Конфигурация не найдена для задачи: {task_dir.name}")
            continue
            
        try:
            # Добавляем путь к tasks в sys.path для корректного импорта
            tasks_path = str(tasks_dir.parent)
            if tasks_path not in sys.path:
                sys.path.insert(0, tasks_path)            
            
             # Формируем путь для импорта модуля
            module_path = f'tasks.{task_dir.name}.config.{task_dir.name}_schedule'
            logger.debug(f"Попытка импорта модуля: {module_path}")
            
            # Импортируем модуль конфигурации
            config_module = importlib.import_module(module_path)
            
            # Ищем переменную TASK_SCHEDULE или SCHEDULE в модуле
            task_configs = _extract_task_configs(config_module, task_dir.name)
            
            if task_configs:
                if isinstance(task_configs, list):
                    # Добавляем информацию о домене к каждой задаче
                    for task_config in task_configs:
                        if 'domain' not in task_config:
                            task_config['domain'] = task_dir.name

                    tasks_schedule.extend(task_configs)
                    logger.info(f"Загружено {len(task_configs)} задач из модуля {task_dir.name}")
                else:
                    logger.warning(f"Конфигурация в {config_file} должна быть списком")
            else:
                logger.warning(f"Не найдена переменная TASK_SCHEDULE или SCHEDULE в {config_file}")
                
        except ImportError as e:
            logger.error(f"Ошибка импорта конфигурации {config_file}: {e}")
        except Exception as e:
            logger.error(f"Неожиданная ошибка при загрузке конфигурации {config_file}: {e}")
    
    logger.info(f"Всего обнаружено задач: {len(tasks_schedule)}")
    
    return tasks_schedule

def _extract_task_configs(config_module, domain_name: str) -> Optional[List[Dict[str, Any]]]:
    """
    Извлекает конфигурации задач из загруженного модуля.
    
    Функция ищет в модуле переменные TASK_SCHEDULE или SCHEDULE
    и возвращает их содержимое. Приоритет отдается TASK_SCHEDULE.
    
    Args:
        config_module: импортированный модуль конфигурации
        domain_name: имя домена для логирования
        
    Returns:
        Optional[List[Dict[str, Any]]]: список конфигураций задач или None
        
    Example:
        >>> module = importlib.import_module('tasks.cameras.config.cameras_config')
        >>> configs = _extract_task_configs(module, 'cameras')
        >>> len(configs)
        3
    """
    # Проверяем наличие переменной TASK_SCHEDULE (приоритет)
    if hasattr(config_module, 'TASK_SCHEDULE'):
        logger.debug(f"Найдена переменная TASK_SCHEDULE в домене {domain_name}")
        return config_module.TASK_SCHEDULE
    
    # Проверяем наличие переменной SCHEDULE (альтернатива)
    elif hasattr(config_module, 'SCHEDULE'):
        logger.debug(f"Найдена переменная SCHEDULE в домене {domain_name}")
        return config_module.SCHEDULE
    
    # Переменные не найдены
    return None

def _validate_schedule_config(schedule: List[Dict[str, Any]]):
    """
    Проверяет корректность конфигурации расписания задач.
    
    Функция выполняет комплексную валидацию каждой задачи:
    1. Проверяет наличие обязательных полей
    2. Валидирует формат расписания
    3. Проверяет корректность времени для daily задач
    4. Валидирует структуру данных
    
    Args:
        schedule: список конфигураций задач для валидации
        
    Raises:
        ValueError: если найдены ошибки в конфигурации
        
    Example:
        >>> schedule = [
        ...     {'name': 'backup', 'user': 'admin', 'schedule': 'daily', 'time': '02:00'},
        ...     {'name': 'cleanup', 'user': 'operator', 'schedule': 'hourly'}
        ... ]
        >>> _validate_schedule_config(schedule)  # Успешно
        
        >>> bad_schedule = [{'name': 'bad', 'schedule': 'daily'}]  # Отсутствует 'user'
        >>> _validate_schedule_config(bad_schedule)  # Raises ValueError
    """
    required_fields = ['user', 'name', 'schedule']
    
    logger.debug(f"Валидация конфигурации для {len(schedule)} задач")
    
    for i, task in enumerate(schedule):
        task_name = task.get('name', f'задача #{i}')
        
        # Проверяем обязательные поля
        _validate_required_fields(task, required_fields, task_name)
        
        # Проверяем корректность расписания (в том числе формат времени для daily задач)
        _validate_schedule_format(task, task_name)
        
        logger.debug(f"{task_name}: конфигурация валидна")
    
    logger.info(f"Валидация завершена успешно для {len(schedule)} задач")


def _validate_required_fields(
    task: Dict[str, Any], 
    required_fields: List[str], 
    task_name: str
) -> None:
    """
    Проверяет наличие обязательных полей в конфигурации задачи.
    
    Args:
        task: конфигурация задачи для проверки
        required_fields: список обязательных полей
        task_name: имя задачи для сообщений об ошибках
        
    Raises:
        ValueError: если отсутствует обязательное поле
        
    Example:
        >>> task = {'name': 'test', 'user': 'admin'}
        >>> _validate_required_fields(task, ['name', 'user'], 'test')  # OK
        >>> _validate_required_fields(task, ['name', 'schedule'], 'test')  # ValueError
    """
    for field in required_fields:
        if field not in task or not task[field]:
            error_msg = f"{task_name}: отсутствует обязательное поле '{field}'"
            logger.error(error_msg)
            raise ValueError(error_msg)


def _validate_schedule_format(task: Dict[str, Any], task_name: str) -> None:
    """
    Проверяет корректность формата расписания задачи.
    
    Валидирует следующие типы расписаний:
    - daily: требует поле 'time' в формате HH:MM
    - hourly: дополнительных полей не требует
    - interval: может требовать дополнительные параметры
    
    Args:
        task: конфигурация задачи
        task_name: имя задачи для сообщений об ошибках
        
    Raises:
        ValueError: если формат расписания некорректен
        
    Example:
        >>> task = {'schedule': 'daily', 'time': '14:30'}
        >>> _validate_schedule_format(task, 'test')  # OK
        
        >>> task = {'schedule': 'daily', 'time': '25:70'}
        >>> _validate_schedule_format(task, 'test')  # ValueError
    """
    schedule_type = task.get('schedule')
    
    # Проверяем расписание типа 'daily'
    if schedule_type == 'daily':
        if 'time' not in task:
            error_msg = f"{task_name}: для daily расписания требуется поле 'time'"
            logger.error(error_msg)
            raise ValueError(error_msg)
        
        # Проверяем формат времени
        _validate_time_format(task.get('time', ''), task_name)


def _validate_time_format(time_str: str, task_name: str) -> None:
    """
    Проверяет корректность формата времени HH:MM.
    
    Args:
        time_str: строка времени для проверки
        task_name: имя задачи для сообщений об ошибках
        
    Raises:
        ValueError: если формат времени некорректен
        
    Example:
        >>> _validate_time_format('14:30', 'test')  # OK
        >>> _validate_time_format('25:70', 'test')  # ValueError
        >>> _validate_time_format('14:30:45', 'test')  # ValueError
    """
    try:
        parts = time_str.split(':')
        if len(parts) != 2:
            raise ValueError("Неверное количество частей")
        
        hour, minute = map(int, parts)
        
        if not (0 <= hour <= 23):
            raise ValueError(f"Час должен быть от 0 до 23, получено: {hour}")
            
        if not (0 <= minute <= 59):
            raise ValueError(f"Минута должна быть от 0 до 59, получено: {minute}")
            
        logger.debug(f"{task_name}: время выполнения {time_str} корректно")
        
    except ValueError as e:
        error_msg = f"{task_name}: неверный формат времени '{time_str}' (ожидается HH:MM): {e}"
        logger.error(error_msg)
        raise ValueError(error_msg)


def get_task_env(task: Dict[str, Any]) -> Dict[str, str]:
    """
    Возвращает объединенные переменные окружения для задачи.
    
    Функция объединяет переменные окружения по приоритету:
    1. DEFAULT_TASK_ENV (базовые переменные для всех задач)
    2. task['env'] (специфичные переменные задачи)
    
    Все значения преобразуются в строки, так как subprocess требует
    строковые значения переменных окружения.
    
    Args:
        task: конфигурация задачи, может содержать поле 'env'
        
    Returns:
        Dict[str, str]: словарь переменных окружения со строковыми значениями
        
    Example:
        >>> task = {
        ...     'name': 'backup',
        ...     'env': {
        ...         'DB_HOST': 'localhost',
        ...         'DB_PORT': 5432,
        ...         'DEBUG': True
        ...     }
        ... }
        >>> env = get_task_env(task)
        >>> env['DB_HOST']
        'localhost'
        >>> env['DB_PORT']
        '5432'
        >>> env['DEBUG']
        'True'
    """
    # Начинаем с копии базовых переменных окружения
    env = DEFAULT_TASK_ENV.copy()
    
    # Получаем специфичные для задачи переменные окружения
    task_env = task.get('env', {})
    
    # Объединяем базовые и специфичные переменные окружения
    for key, value in task_env.items():
        # добавляем в env только если значение в task_env не None
        if value is not None:
            # Добавляем к env = DEFAULT_TASK_ENV преобразованные значение в строку (требование для subprocess) из task['env']
            env[key] = str(value)
    
    # Если в DEFAULT_TASK_ENV или задаче остались ключи с None, удаляем их тоже:
    filtered_env = {k: v for k, v in env.items() if v is not None}

    return filtered_env


def reload_schedule() -> List[Dict[str, Any]]:
    """
    Перезагружает конфигурацию расписания из всех задач.
    
    Функция полезна для динамического обновления конфигурации
    без перезапуска основного процесса планировщика.
    Выполняет полный цикл: обнаружение -> загрузка -> валидация.
    
    Returns:
        List[Dict[str, Any]]: обновленный список задач
        
    Raises:
        ValueError: если новая конфигурация содержит ошибки
        ImportError: если не удается загрузить модули конфигурации
        
    Example:
        >>> # После изменения конфигурационных файлов
        >>> new_schedule = reload_schedule()
        >>> len(new_schedule)
        7  # Обновленное количество задач
        
    Note:
        Функция не обновляет глобальную переменную SCHEDULE,
        возвращает новый список для ручного управления.
    """

    logger.info("Перезагрузка конфигурации расписания")
    
    try:
        # Обнаруживаем и загружаем конфигурации
        new_schedule = _discover_task_configs()
        
        # Валидируем новую конфигурацию
        _validate_schedule_config(new_schedule)
        
        logger.info(f"Конфигурация успешно перезагружена: {len(new_schedule)} задач")
        return new_schedule
        
    except Exception as e:
        logger.error(f"Ошибка при перезагрузке конфигурации: {e}")
        raise

def get_tasks_by_user(user: str) -> List[Dict[str, Any]]:
    """
    Возвращает все задачи для указанного пользователя.
    
    Args:
        user: имя пользователя для фильтрации задач
        
    Returns:
        List[Dict[str, Any]]: список задач пользователя
        
    Example:
        >>> operator_tasks = get_tasks_by_user('operator')
        >>> len(operator_tasks)
        3
        >>> all(task['user'] == 'operator' for task in operator_tasks)
        True
    """
    return [task for task in SCHEDULE if task.get('user') == user]


def get_task_by_name(name: str, user: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """
    Возвращает задачу по имени, опционально фильтруя по пользователю.
    
    Args:
        name: имя задачи для поиска
        user: опциональный фильтр по пользователю
        
    Returns:
        Optional[Dict[str, Any]]: найденная задача или None
        
    Example:
        >>> task = get_task_by_name('backup_db')
        >>> task['name']
        'backup_db'
        
        >>> task = get_task_by_name('backup_db', user='admin')
        >>> task is not None
        True
    """
    for task in SCHEDULE:
        if task.get('name') == name:
            if user is None or task.get('user') == user:
                return task
    return None


def get_schedule_summary() -> Dict[str, Any]:
    """
    Возвращает сводную информацию о расписании задач.
    
    Returns:
        Dict[str, Any]: словарь со статистикой расписания
        
    Example:
        >>> summary = get_schedule_summary()
        >>> summary['total_tasks']
        12
        >>> summary['users']
        ['admin', 'operator', 'backup_user']
        >>> summary['schedule_types']
        {'daily': 8, 'hourly': 3, 'interval': 1}
    """
    users = set()
    schedule_types = {}
    
    for task in SCHEDULE:
        # Собираем уникальных пользователей
        if 'user' in task:
            users.add(task['user'])
        
        # Подсчитываем типы расписаний
        schedule_type = task.get('schedule', 'unknown')
        schedule_types[schedule_type] = schedule_types.get(schedule_type, 0) + 1
    
    return {
        'total_tasks': len(SCHEDULE),
        'users': sorted(list(users)),
        'schedule_types': schedule_types,
        'task_names': [task.get('name', 'Unknown') for task in SCHEDULE]
    }



def print_schedule(
    user: Optional[str] = None,
    domain: Optional[str] = None,
    show_env: bool = False,
    show_args: bool = True,
    show_time: bool = True,
    show_module: bool = True,
    sort_by: str = "time"
):
    """
    Красиво выводит задачи расписания с возможностью фильтрации по пользователю и домену.

    Args:
        user (str, optional): фильтр по пользователю
        domain (str, optional): фильтр по домену (например, 'cameras', 'system')
        show_env (bool): выводить ли переменные окружения задачи
        show_args (bool): выводить ли аргументы задачи
        show_time (bool): выводить ли время/тип расписания
        show_module (bool): выводить ли модуль задачи
        sort_by (str): поле для сортировки ('time', 'name', 'user', 'domain')
    Пример использования:
        from scheduler_runner.schedule_config import print_schedule
        
        # Вывести все задачи
        print_schedule()

        # Только для пользователя 'operator'
        print_schedule(user='operator')

        # Только для домена 'system'
        print_schedule(domain='system')

        # Для анализа пересечений по времени (например, только daily)
        print_schedule(sort_by='time')    
        
    """
    from pprint import pprint

    filtered = SCHEDULE
    if user:
        filtered = [t for t in filtered if t.get("user") == user]
    if domain:
        filtered = [t for t in filtered if t.get("domain") == domain]

    def sort_key(task):
        return task.get(sort_by) or ""

    filtered = sorted(filtered, key=sort_key)

    print(f"\n{'='*30} SCHEDULE (user={user or 'ANY'}, domain={domain or 'ANY'}) {'='*30}")
    for i, task in enumerate(filtered, 1):
        print(f"{i:2d}. {task.get('name', '???')}", end="")
        if show_time:
            print(f" | {task.get('schedule', '')}", end="")
            if task.get('schedule') == 'daily':
                print(f" {task.get('time', '')}", end="")
        print(f" | user: {task.get('user', '')}", end="")
        if 'domain' in task:
            print(f" | domain: {task['domain']}", end="")
        if show_module:
            print(f"\n    module: {task.get('module', '')}", end="")
        if show_args and task.get('args'):
            print(f"\n    args: {task['args']}", end="")
        if show_env and task.get('env'):
            print(f"\n    env: {task['env']}", end="")
        print("\n" + "-"*80)
    print(f"Всего задач: {len(filtered)}\n")



# Загружаем конфигурацию задач при импорте модуля
logger.info("Инициализация системы расписания задач")
SCHEDULE: List[Dict[str, Any]] = _discover_task_configs()

# print("[DEBUG] Итоговый SCHEDULE:")
# for task in SCHEDULE:
#   print(task)

# Выполняем валидацию при импорте модуля
try:
    _validate_schedule_config(SCHEDULE)
    logger.info(f"Система расписания инициализирована: загружено и проверено {len(SCHEDULE)} задач")

    # Выводим краткую сводку в лог
    summary = get_schedule_summary()
    logger.info(f"Пользователи: {', '.join(summary['users'])}")
    logger.info(f"Типы расписаний: {summary['schedule_types']}")    
except Exception as e:
    logger.error(f"Критическая ошибка при инициализации системы расписания: {e}")
    raise

