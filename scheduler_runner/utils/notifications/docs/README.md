# Изолированный микросервис уведомлений

## Общее описание

Микросервис уведомлений представляет собой изолированную систему, которая принимает все специфичные параметры извне и возвращает результат отправки уведомления. Архитектура спроектирована таким образом, чтобы микросервис не содержал жестко закодированных значений, зависимостей от внешних конфигураций или специфичных настроек, привязанных к конкретной реализации.

## Архитектура

### Компоненты микросервиса

1. **Интерфейс взаимодействия**
   - `send_notification()` - отправка одиночного уведомления
   - `send_batch_notifications()` - пакетная отправка уведомлений
   - `test_connection()` - проверка подключения к системе уведомлений

2. **Базовые классы**
   - `BaseNotifier` - абстрактный класс для отправки уведомлений
   - `BaseMessageSender` - базовый класс для конкретных отправителей
   - `TelegramNotifier` - реализация для Telegram

3. **Конфигурации**
   - `BASE_NOTIFIER_CONFIG` - минимальный набор общих параметров
   - `TELEGRAM_NOTIFIER_CONFIG` - минимальная специфичная конфигурация

## Параметры, принимаемые извне

### 1. Параметры подключения
- `TELEGRAM_BOT_TOKEN` - токен Telegram бота
- `TELEGRAM_CHAT_ID` - ID чата для отправки
- Другие специфичные параметры подключения

### 2. Сообщение для отправки
- Может быть строкой или словарем
- Поддержка шаблонов через указание `template` и `data`

### 3. Внешний логгер
- Готовый объект логгера для использования в микросервисе
- Позволяет интегрировать логирование в общую систему

### 4. Шаблоны сообщений (опционально)
- Словарь с шаблонами для форматирования сообщений
- Поддержка подстановки данных в шаблоны

## Использование микросервиса

### 1. Простая отправка сообщения
```python
from scheduler_runner.utils.notifications import send_notification

connection_params = {
    "TELEGRAM_BOT_TOKEN": "your_token",
    "TELEGRAM_CHAT_ID": "your_chat_id"
}

result = send_notification(
    message="Привет, мир!",
    connection_params=connection_params
)
```

### 2. Отправка с использованием шаблона
```python
templates = {
    "welcome": "Добро пожаловать, {name}! Ваш ID: {user_id}"
}

message = {
    "template": "welcome",
    "data": {
        "name": "Иван",
        "user_id": "12345"
    }
}

result = send_notification(
    message=message,
    connection_params=connection_params,
    templates=templates
)
```

### 3. Отправка с внешним логгером
```python
from scheduler_runner.utils.logging import configure_logger

logger = configure_logger(user="system", task_name="NotificationTask")

result = send_notification(
    message="Сообщение с внешним логгером",
    connection_params=connection_params,
    logger=logger
)
```

### 4. Проверка подключения
```python
from scheduler_runner.utils.notifications import test_connection

result = test_connection(connection_params)
if result["success"]:
    print("Подключение успешно")
else:
    print("Ошибка подключения")
```

## Преимущества архитектуры

1. **Полная изоляция** - микросервис не содержит специфичных параметров
2. **Гибкость** - поддержка различных способов отправки и форматов сообщений
3. **Интеграция** - возможность передачи внешнего логгера
4. **Расширяемость** - легко добавлять новые способы отправки уведомлений
5. **Безопасность** - все чувствительные параметры передаются извне
6. **Тестируемость** - возможность тестирования подключения отдельно

## Использование в центральном процессоре домена

Центральный процессор домена может использовать микросервис следующим образом:
1. Подготовить параметры подключения
2. Подготовить сообщение (сырое или с использованием шаблонов)
3. Передать готовый логгер для интеграции с общей системой логирования
4. Вызвать `send_notification()` для отправки уведомления
5. Обработать результат отправки

Такая архитектура позволяет использовать микросервис в различных контекстах без изменений внутренней логики.