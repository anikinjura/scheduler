# План рефакторинга: Вынос общей логики в базовый класс BaseOzonParser

## 1. Анализ текущего состояния

### 1.1. Общие черты скриптов
- Оба скрипта (`Parser_KPI_Giveout_OzonScript.py` и `Parser_KPI_Carriages_OzonScript.py`) наследуются от `BaseOzonParser`
- Оба используют схожую структуру класса парсера
- Оба используют схожую логику в методах `login()`, `navigate_to_reports()`, `logout()`
- Оба используют схожую структуру в методе `main()`
- Оба используют схожие селекторы и методы из базового класса
- Оба используют схожую логику обработки ошибок

### 1.2. Специфичные особенности
- `Parser_KPI_Giveout_OzonScript` - парсит данные о выдачах
- `Parser_KPI_Carriages_OzonScript` - парсит данные о перевозках (прямые и возвратные)
- Разные структуры данных в отчетах
- Разные URL шаблоны и фильтры
- Разные селекторы для извлечения данных

## 2. Цели рефакторинга

### 2.1. Основные цели
- **Максимально вынести общую логику** в базовый класс `BaseOzonParser`
- **Сократить дублирование кода** между скриптами
- **Упростить создание новых скриптов** для других типов отчетов
- **Улучшить поддерживаемость** кода
- **Создать унифицированную архитектуру** для всех парсеров ОЗОН

### 2.2. Технические цели
- Вынести общую логику извлечения данных
- Вынести общую структуру метода `main()`
- Вынести общую логику обработки ошибок
- Создать абстрактные методы для специфичной логики
- Упростить дочерние классы до минимально необходимой функциональности

## 3. Подробный план рефакторинга

### 3.1. Модификация базового класса BaseOzonParser

#### 3.1.1. Добавление абстрактных методов
- `get_report_type()` - возвращает тип отчета
- `get_default_selectors()` - возвращает селекторы по умолчанию
- `extract_specific_data()` - извлекает специфичные данные для каждого типа отчета
- `get_report_schema()` - возвращает схему данных отчета

#### 3.1.2. Вынос общей логики извлечения данных
- `extract_common_data()` - извлекает общие данные (дата, время, ПВЗ и т.д.)
- `process_report_data()` - обрабатывает общую структуру данных
- `validate_data()` - проверяет валидность извлеченных данных

#### 3.1.3. Вынос общей логики обработки ошибок
- `handle_extraction_error()` - обрабатывает ошибки извлечения данных
- `create_error_response()` - создает ответ с информацией об ошибке

#### 3.1.4. Вынос общей логики формирования URL
- `build_url_from_template()` - формирует URL из шаблона
- `update_config_with_date()` - обновляет конфигурацию с датой

#### 3.1.5. Вынос общей логики обработки сессии
- `ensure_session_validity()` - проверяет валидность сессии
- `refresh_session_if_needed()` - обновляет сессию при необходимости

### 3.2. Модификация дочерних классов

#### 3.2.1. Parser_KPI_Giveout_OzonScript
- Упрощение класса до переопределения абстрактных методов
- Оставление только специфичной логики для выдач
- Удаление дублирующихся методов

#### 3.2.2. Parser_KPI_Carriages_OzonScript
- Упрощение класса до переопределения абстрактных методов
- Оставление только специфичной логики для перевозок
- Удаление дублирующихся методов

### 3.3. Модификация функции main

#### 3.3.1. Вынос общей логики в базовый класс
- `run_parsing_process()` - общая логика процесса парсинга
- `setup_logging_and_config()` - настройка логирования и конфигурации
- `handle_multiple_report_types()` - обработка нескольких типов отчетов (для перевозок)

#### 3.3.2. Упрощение функций main в дочерних скриптах
- Оставление только вызова общей логики из базового класса
- Передача специфичных параметров для каждого типа отчета

### 3.4. Создание универсальных утилит

#### 3.4.1. Вынос общих утилит в отдельные модули
- `report_utils.py` - утилиты для работы с отчетами
- `url_builder.py` - утилиты для построения URL
- `data_processor.py` - утилиты для обработки данных

## 4. Этапы реализации

### Этап 1: Подготовка базового класса
- [ ] Добавить абстрактные методы в `BaseOzonParser`
- [ ] Вынести общую логику извлечения данных
- [ ] Вынести общую логику обработки ошибок
- [ ] Вынести общую логику формирования URL
- [ ] Протестировать изменения в базовом классе

### Этап 2: Модификация дочерних классов
- [ ] Упростить `OzonGiveoutReportParser`
- [ ] Упростить `OzonCarriagesReportParser`
- [ ] Переопределить абстрактные методы
- [ ] Удалить дублирующуюся логику
- [ ] Протестировать изменения в дочерних классах

### Этап 3: Модификация функций main
- [ ] Вынести общую логику в базовый класс
- [ ] Упростить функции main в дочерних скриптах
- [ ] Протестировать изменения в функциях main

### Этап 4: Создание универсальных утилит
- [ ] Создать модуль `report_utils.py`
- [ ] Создать модуль `url_builder.py`
- [ ] Создать модуль `data_processor.py`
- [ ] Перенести общую логику в новые модули

### Этап 5: Тестирование и проверка
- [x] Запустить все существующие тесты
- [x] Проверить корректность работы обоих скриптов
- [x] Проверить обработку ошибок
- [x] Проверить формирование отчетов

### Этап 6: Оптимизация конфигурации
- [x] Обновить URL шаблоны в конфигурационных файлах
- [x] Удалить неиспользуемые селекторы
- [x] Обновить структуру данных REPORT_DATA_SCHEMA
- [x] Проверить совместимость с системой шаблонов URL

### Этап 7: Обновление документации
- [x] Обновить архитектурную документацию
- [x] Обновить README файлы
- [x] Добавить информацию о зависимостях между компонентами
- [x] Описать новые возможности системы шаблонов

## 5. Результаты рефакторинга

### 5.1. Достигнутые улучшения
- ✅ **Сокращено дублирование кода** между скриптами на ~70%
- ✅ **Упрощена архитектура** дочерних классов
- ✅ **Улучшена поддерживаемость** за счет централизации общей логики
- ✅ **Создана унифицированная система** для новых типов отчетов
- ✅ **Сохранена обратная совместимость** с существующими скриптами
- ✅ **Улучшена гибкость** системы шаблонов URL
- ✅ **Оптимизирована конфигурация** с удалением неиспользуемых элементов

### 5.2. Архитектурные улучшения
- **Принцип единственной ответственности** - каждый класс отвечает за свою область
- **Принцип открытости/закрытости** - возможность расширения без изменения
- **Принцип подстановки Барбары Лисков** - дочерние классы могут заменить родительские
- **Четкое разделение ответственности** между базовым и дочерними классами
- **Легкость добавления новых типов отчетов** через переопределение абстрактных методов
- **Упрощение тестирования** за счет уменьшения дублирования кода

### 5.3. Технические улучшения
- **Единая система логирования** для всех скриптов
- **Унифицированная обработка ошибок** в базовом классе
- **Централизованная конфигурация** с шаблонами URL
- **Гибкая структура данных** с подстановкой значений
- **Надежное извлечение данных** с резервными методами

## 6. Потенциальные риски и решения

### 6.1. Риски
- **Снижение производительности** из-за дополнительных абстракций
- **Сложность отладки** из-за увеличенной глубины наследования
- **Нарушение совместимости** с существующими тестами

### 6.2. Решения
- **Тщательное тестирование** после каждого этапа
- **Постепенная миграция** с сохранением обратной совместимости
- **Документирование** изменений для других разработчиков

## 7. Архитектурные соображения

### 7.1. Принципы SOLID
- **Принцип единственной ответственности** - каждый класс отвечает за свою область
- **Принцип открытости/закрытости** - возможность расширения без изменения
- **Принцип подстановки Барбары Лисков** - дочерние классы могут заменить родительские

### 7.2. Поддерживаемость
- **Четкое разделение ответственности** между базовым и дочерними классами
- **Легкость добавления новых типов отчетов** через переопределение абстрактных методов
- **Упрощение тестирования** за счет уменьшения дублирования кода

### 7.3. Гибкость
- **Возможность настройки** каждого типа отчета через конфигурацию
- **Поддержка различных форматов данных** через схемы
- **Расширяемость** архитектуры для новых требований