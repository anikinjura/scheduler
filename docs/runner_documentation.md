# Документация модуля runner.py

## Обзор

Модуль `runner.py` — основная точка входа для планировщика задач. Его запускают из Windows Task Scheduler или вручную, и он выполняет задачи по расписанию или в принудительном режиме (`--task`).

## Архитектура модуля

```
runner.py
├── parse_arguments()     # Парсинг CLI-аргументов
├── filter_tasks()        # Фильтрация задач по пользователю и (опционально) по имени
├── sort_tasks_by_time()  # Сортировка задач по времени (часы и минуты)
├── execute_task()        # Проверка расписания, запуск подпроцесса и детальное логирование
└── main()                # Основной цикл: парсинг, фильтрация, запуск, статистика, sys.exit
```

---

## Функции

### 1. parse_arguments()

**Назначение**
Собирает и валидирует аргументы из командной строки.

**Сигнатура**

```python
parse_arguments() -> argparse.Namespace
```

**Аргументы**

* `--user` (str, **обязательный**) — имя пользователя для фильтрации задач
* `--task` (str, *опционально*) — название одной задачи для принудительного запуска (`force_run`)
* `--detailed` (флаг) — включает DEBUG‑уровень в логгере

**Пример**

```bash
python runner.py --user operator --detailed
```

---

### 2. filter_tasks()

**Назначение**
Отбирает из глобальной переменной `SCHEDULE` те задачи, которые совпадают с указанным `user` и (при необходимости) с `task_name`.

**Сигнатура**

```python
filter_tasks(
    all_tasks: List[Dict[str, Any]],
    user: str,
    task_name: Optional[str] = None
) -> List[Dict[str, Any]]
```

**Логика**

- Приводит и `user`, и `task['user']` к lowercase и фильтрует.
- Если указан `task_name`, дополнительно отбирает по `task['name']` (тоже без учёта регистра).

**Покрытие тестами:**  
Проверяется, что фильтрация по пользователю и имени задачи нечувствительна к регистру, корректно работает отсутствие совпадений.

---

### 3. sort_tasks_by_time()

**Назначение**
Сортирует задачи по времени (часы и минуты) из поля `time`.  
Если `time` отсутствует или некорректен, задача идёт первой.

**Сигнатура**

```python
sort_tasks_by_time(tasks: List[Dict[str, Any]]) -> List[Dict[str, Any]]
```

**Покрытие тестами:**  
Проверяется, что задачи без корректного `time` идут первыми, остальные — по возрастанию времени.

---

### 4. execute_task()

**Назначение**
Выполняет одну задачу: проверяет расписание (через should_run_now), подготавливает окружение, запускает подпроцесс и логирует каждую стадию.

**Сигнатура**

```python
execute_task(
    task: Dict[str, Any],
    logger,               # экземпляр logging.getLogger()
    force_run: bool = False
) -> bool
```

**Основные шаги**

1. **Проверка расписания**
   - Если `force_run=True`, задача запускается всегда.
   - Если нет — проверяется через `should_run_now` (логика «окна» по часу для daily).
   - Если время не подошло, логируется и возвращается `False`.

2. **Подготовка параметров**
   - Получение имени модуля, аргументов, окружения, таймаута, рабочей директории.

3. **Запуск подпроцесса и обработка ошибок**
   - Любое исключение при запуске логируется через `logger.exception(...)`.

4. **Логирование результата и возврат**
   - Успех — `logger.info`, неудача — `logger.error`.

**Покрытие тестами:**  
Проверяется логирование старта, успеха, ошибки, обработка исключений, корректная работа с force_run и should_run_now.

---

### 5. main()

**Назначение**
Оркеструет весь процесс: от импорта `SCHEDULE` до выхода с определённым кодом.

**Сигнатура**

```python
main() -> None
```

(вызывает `sys.exit(code)` в зависимости от результата)

**Коды выхода**

| Код | Ситуация                                                                             |
| --- | ------------------------------------------------------------------------------------ |
| 0   | Все задачи выполнены успешно                                                         |
| 1   | По крайней мере одна задача завершилась с ошибкой                                    |
| 2   | Нет задач для указанного user/task **или** прерывание Ctrl+C                         |
| 3   | Критическая ошибка: ImportError, пустой SCHEDULE или любое непредвиденное исключение |

**Ход выполнения**

1. **Импорт и проверка**
   - При ошибке импорта или пустом SCHEDULE — `sys.exit(3)`.

2. **Парсинг аргументов**
   - Через `parse_arguments()`.

3. **Фильтрация задач**
   - Через `filter_tasks()`. Если задач нет — `sys.exit(2)`.

4. **Сортировка задач**
   - Через `sort_tasks_by_time()`.

5. **Выполнение задач**
   - Для каждой задачи вызывается `execute_task()`, собирается статистика.

6. **Итоговая статистика и выход**
   - Если все задачи успешны — `sys.exit(0)`, иначе — `sys.exit(1)`.

7. **Обработка Ctrl+C и прочих исключений**
   - `sys.exit(2)` при KeyboardInterrupt, `sys.exit(3)` при других ошибках.

**Покрытие тестами:**  
Проверяется поведение при отсутствии задач, успешном и неуспешном выполнении, обработка исключений и коды выхода.

---

## Связь с тестами

Тесты в `tests/test_runner.py` и `tests/test_utils.py` проверяют:

* **filter_tasks**
  — нечувствительность к регистру и правильную фильтрацию по `user` и `task_name`.

* **sort_tasks_by_time**
  — задачи без корректного `time` идут первыми, остальные сортируются по времени.

* **execute_task**
  — логирование старта, успеха, ошибки, обработка исключений, корректная работа с force_run и should_run_now.

* **main**
  — коды выхода: 0 (все успехи), 1 (есть ошибки), 2 (нет задач или Ctrl+C), 3 (критическая ошибка).

* **should_run_now**
  — логика «окна» для daily (по часу), поддержка hourly, once, ошибки формата.

* **run_subprocess**
  — успешный запуск, таймаут, очистка lock-файла, идемпотентность (не повторяет запуск в одном окне).

---

## Примеры запуска

```bash
# Запуск всех задач пользователя operator
python runner.py --user operator

# Принудительный запуск конкретной задачи с подробным логированием
python runner.py --user admin --task backup_database --detailed
```

---

## Обработка ошибок и логирование

* **Ошибка импорта/пустой SCHEDULE**
  -> `sys.exit(3)`
* **Неподходящее время (schedule)**
  -> лог `INFO: Задача 'X' не должна запускаться…`, возвращает False
* **Ошибка в подпроцессе**
  -> `logger.exception(...)`, возвращает False
* **Ctrl+C**
  -> `sys.exit(2)`

Логи собираются в структуре:

```
logs/
└── <user>/
    └── <task_name>/
        └── YYYY-MM-DD.log
```

---

## Особенности, отражённые в тестах

- Проверяется сортировка задач по времени (часы и минуты), задачи без корректного времени идут первыми.
- Проверяется идемпотентность запуска задач в рамках одного окна (hourly/daily).
- Проверяется корректная обработка исключений и возврат кодов выхода.
- Проверяется отсутствие дублирования логгеров и корректная работа detailed-логов.
- Проверяется фильтрация переменных окружения (None не попадают в ENV).

---