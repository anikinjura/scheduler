# Планировщик задач

Этот проект представляет собой модульный планировщик задач, предназначенный для автоматического выполнения различных скриптов по расписанию. Ядро системы динамически обнаруживает, загружает и выполняет задачи, определенные в отдельных "доменах" (например, `cameras`, `system`).

---

## Архитектура

Планировщик построен на модульной архитектуре, где ядро (`scheduler_runner`) отвечает за общую логику, а конкретные задачи инкапсулированы в своих директориях (`scheduler_runner/tasks/<domain>`).

1.  **Точка входа (`scheduler_runner/runner.py`)**:
    -   Принимает аргументы командной строки: `--user`, `--task`, `--detailed_logs`.
    -   Фильтрует задачи по пользователю и, опционально, по имени задачи.
    -   Последовательно выполняет отфильтрованные задачи.

2.  **Конфигурация расписания (`scheduler_runner/schedule_config.py`)**:
    -   Автоматически сканирует директорию `scheduler_runner/tasks/` на наличие доменов задач.
    -   В каждом домене ищет файл `config/<domain>_schedule.py`.
    -   Этот файл, в свою очередь, собирает расписания из `config/scripts/*_config.py` с помощью утилиты `schedule_utils.py`.
    -   Все найденные расписания объединяются в единый список `SCHEDULE`, который используется ядром.

3.  **Выполнение задачи (`scheduler_runner/utils/subprocess.py`)**:
    -   Каждая задача запускается в отдельном подпроцессе для изоляции.
    -   Используются lock-файлы для предотвращения одновременного запуска одной и той же задачи.
    -   Ведется проверка на повторный запуск в рамках одного "окна" времени (например, для ежечасных задач).

---

## Структура проекта

```
/
├── scheduler_runner/           # Ядро планировщика
│   ├── runner.py               # Главный исполняемый файл
│   ├── schedule_config.py      # Логика сбора и валидации всех расписаний
│   ├── tasks/                  # Директория с задачами
│   │   ├── cameras/            # Пример домена задач "cameras"
│   │   └── system/             # Пример домена задач "system"
│   └── utils/                  # Вспомогательные утилиты (логирование, ФС, и т.д.)
│
├── config/                     # Глобальная конфигурация
│   └── base_config.py          # Базовые пути и переменные
│
├── logs/                       # Директория для лог-файлов
├── pvz_config.ini              # Конфигурация объекта (ID и режим работы)
├── requirements.txt            # Зависимости проекта
└── README.md                   # Эта документация
```

---

## Конфигурация

### `pvz_config.ini`

Этот файл должен находиться в `C:\tools\pvz_config.ini` и содержать:

-   `PVZ_ID`: Уникальный идентификатор объекта (например, `10`).
-   `ENV_MODE`: Режим окружения (`production` или `test`). Влияет на выбор путей и параметров в задачах.

### Конфигурация задачи

Каждая задача в расписании представляет собой словарь со следующими ключами:

-   `name` (str): Уникальное имя задачи.
-   `user` (str): Имя пользователя, от имени которого запускается задача.
-   `module` (str): Путь к Python-модулю для запуска (например, `scheduler_runner.tasks.cameras.CopyScript`).
-   `schedule` (str): Тип расписания (`daily`, `hourly`).
-   `time` (str): Время запуска для `daily` расписания (формат `HH:MM`).
-   `args` (list): Список аргументов командной строки для скрипта.
-   `env` (dict, optional): Словарь переменных окружения для подпроцесса.
-   `timeout` (int, optional): Таймаут выполнения в секундах.
-   `no_timeout_control` (bool, optional): Если `True`, задача запускается в режиме "fire-and-forget" без контроля времени выполнения. Полезно для долгих процессов, которые не должны блокировать планировщик. По умолчанию `False`.

---

## Использование

### Запуск планировщика

Планировщик запускается из командной строки. Рекомендуется использовать `pythonw.exe` для запуска в фоновом режиме без окна консоли.

```bash
# Запустить все задачи для пользователя 'operator' по расписанию
pythonw -m scheduler_runner.runner --user operator

# Принудительно запустить задачу 'CopyScript' для пользователя 'operator'
pythonw -m scheduler_runner.runner --user operator --task CopyScript

# Запустить задачи с подробным логированием (уровень DEBUG)
pythonw -m scheduler_runner.runner --user operator --detailed_logs
```

### Аргументы командной строки

-   `--user <имя>`: **(Обязательный)** Указывает, для какого пользователя фильтровать задачи.
-   `--task <имя>`: (Опциональный) Имя конкретной задачи для принудительного запуска, игнорируя расписание.
-   `--detailed_logs`: (Опциональный) Включает запись `DEBUG` логов в отдельный файл.

---

## Добавление новой задачи

1.  **Создать директорию домена**:
    -   В `scheduler_runner/tasks/` создайте новую папку, например, `my_new_task`.

2.  **Написать скрипт(ы)**:
    -   Внутри `my_new_task/` разместите один или несколько Python-скриптов, которые будут выполнять нужную логику (например, `MyScript.py`).

3.  **Создать конфигурацию скрипта**:
    -   Создайте структуру папок `my_new_task/config/scripts/`.
    -   Внутри создайте файл `myscript_config.py`.
    -   В этом файле определите переменную `SCHEDULE` — список словарей, описывающих одну или несколько задач, которые запускают `MyScript.py` с разными параметрами.

4.  **Создать конфигурацию расписания домена**:
    -   В `my_new_task/config/` создайте файл `my_new_task_schedule.py`.
    -   В нем используйте утилиту `collect_task_schedule` для автоматического сбора всех расписаний из папки `scripts/`:
        ```python
        from scheduler_runner.utils.schedule_utils import collect_task_schedule
        TASK_SCHEDULE = collect_task_schedule("my_new_task")
        ```

После этих шагов ядро планировщика автоматически обнаружит и подключит новую задачу.

---

## Логирование

-   Логи всех задач и ядра хранятся в директории `logs/`.
-   Структура логов: `logs/<user>/<task_name>/<YYYY-MM-DD>.log`.
-   При использовании флага `--detailed_logs` создается дополнительный файл `<YYYY-MM-DD>_detailed.log` с отладочной информацией.
-   Старые логи автоматически удаляются.
